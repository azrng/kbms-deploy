import{_ as i,W as o,X as n,Y as e,Z as t,$ as s,a0 as a,y as d}from"./framework.cf23f0c7.js";const l={},c=a('<h1 id="docker" tabindex="-1"><a class="header-anchor" href="#docker" aria-hidden="true">#</a> Docker</h1><h1 id="_1-概述" tabindex="-1"><a class="header-anchor" href="#_1-概述" aria-hidden="true">#</a> 1. 概述</h1><h2 id="_1-1-docker简介" tabindex="-1"><a class="header-anchor" href="#_1-1-docker简介" aria-hidden="true">#</a> 1.1 Docker简介</h2><p><strong>Docker 是一个开源的应用容器引擎，是用Go语言开发的</strong>。用于开发、交付和运行应用程序的开放平台，能够将应用程序与基础设施分开，从而可以快速交付软件。</p><p>看看Docker 的Logo图</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142348172.webp" alt="图片" loading="lazy"></p><p>，Docker就好比是下面的小鲸鱼，上面装满的每个集装箱(方块)可以理解为容器，不管集装箱里面装的什么，统一按集装箱的形式打包存放、运输即可，集装箱之间互不影响；即Docker不在乎容器里的内容是什么，<strong>统一基于容器这种形式进行标准化管理，容器之间相互隔离</strong>，所以Docker上运行的多个容器是相互不影响的。</p><p>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），通常社区版足够用了，功能强大，还免费。</p>',8),p={href:"https://labs.play-with-docker.com/",target:"_blank",rel:"noopener noreferrer"},g={href:"https://www.cnblogs.com/Can-daydayup/p/15585714.html",target:"_blank",rel:"noopener noreferrer"},m=a(`<h2 id="_1-2-docker架构" tabindex="-1"><a class="header-anchor" href="#_1-2-docker架构" aria-hidden="true">#</a> 1.2 Docker架构</h2><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142348441.webp" alt="图片" loading="lazy">Docker Architecture Diagram</p><p><strong>Docker是客户端/服务器模式架构(C/S)，Client(客户端)和Docker daemon(守护进程)通信， 后者接收到客户端指令并执行</strong>。简述上图的三个流程：</p><ul><li><strong>客户端(Client)</strong> 发送<strong>docker build</strong>指令， <strong>服务端(Docker daemon)</strong> 收到指令之后就执行，将对应文件打包生成为<strong>镜像(Images)</strong> ；</li><li><strong>客户端(Client)</strong> 发送<strong>docker pull</strong>指令，<strong>服务端(Docker daemon)</strong> 收到指令之后就执行，从<strong>远程仓储中(Registry)</strong> 寻找<strong>镜像(Images)</strong> ，并<strong>下载到Docker主机上(DOCKER_HOST)</strong> ，如果找不到就报错；</li><li><strong>客户端(Client)</strong> 发送<strong>docker run</strong>指令，<strong>服务端(Docker daemon)</strong> 收到指令之后就执行，先从本地查找<strong>镜像(Images)</strong> ，如果本地存在，直接通过镜像启动<strong>容器(Containers)</strong> 实例；如果本地没有镜像(Images)，就会从远程仓储中(Registry)下载，然后再根据镜像启动<strong>容器(Containers)</strong> 实例，如果都没找到，那就报错。</li></ul><p>上面只是用三关键指令大概描述了从客户端到服务端的执行流程，其实还有很多指令，后续会专门整理文章分享。</p><p>上图术语解释及作用：</p><ul><li><strong>Docker daemon(守护进程)</strong> ：负责监听客户端发过来的指令请求，并管理Docker的各种对象，如镜像(Images)、容器(Containers)、网络等。</li><li><strong>Client(客户端)</strong> ：用户和Docker主机交互的主要方式，就是用来发指令请求的。</li><li><strong>远程仓储(Registry)</strong> ：用于各种镜像的存储，<strong>Docker Hub是最大的镜像存储库</strong>，基本上平时能用到的镜像都可以找到；为了提升拉取速度，可以指定国内的一些仓储。</li><li><strong>镜像(Images)</strong> ：是一个启动<strong>容器(Containers)</strong> 的只读模板；比较容易理解的比喻：镜像就是编程语言中的类(Class)，容器就是通过类(Class) new出来的实例。</li><li><strong>容器(Containers)</strong> ：就是<strong>镜像(Images)</strong> 可运行的实例。</li></ul><h2 id="_1-3-docker带来的好处" tabindex="-1"><a class="header-anchor" href="#_1-3-docker带来的好处" aria-hidden="true">#</a> 1.3 Docker带来的好处</h2><ul><li><strong>开发更加敏捷：</strong> 让开发人员可以自由定义环境，创建和部署的应用程序更快、更容易，运维人员快速应对变化也更加灵活性。</li><li><strong>高可移植性和扩展性：</strong> Docker容器可以运行在各种设备环境中，如开发电脑、虚拟机、服务器上等；根据业务需求，可实时扩展或拆除应用程序及相关服务；</li><li><strong>充分利用硬件资源</strong>：Docker轻量级、启动快，能共用公共服务，不像传统的虚拟机那样，需要单独虚拟出整个系统，占用资源多，速度还不够快。Docker容器之间相互隔离，互不冲突，所以同时可运行很多个容器，充分利用资源。</li></ul><p>理论先说那么多，主要是实操应用，用明白了，理论自然就清晰了。</p><h1 id="_2-安装" tabindex="-1"><a class="header-anchor" href="#_2-安装" aria-hidden="true">#</a> 2. 安装</h1><p>安装步骤看本网站其他文章有叙述</p><h1 id="_3-初体验" tabindex="-1"><a class="header-anchor" href="#_3-初体验" aria-hidden="true">#</a> 3. 初体验</h1><p>安装完成之后，这里不急着往下说，先来体验一下；很方便的就将自己的项目打包然后运行，步骤如下：</p><ul><li><p>准备一个项目</p><p>这里就直接创建一个默认的API项目(基于.NetCore3.1)即可，什么都不做。</p></li><li><p>编写Dockerfile</p><p>在项目根目录下增加一个Dockerfile文件，里面内容如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142348076.webp" alt="图片" loading="lazy"></p><p>具体内容如下</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>FROM mcr.microsoft.com/dotnet/core/aspnet:3.1-buster-slim
WORKDIR /app
COPY . .
EXPOSE 80
ENTRYPOINT [&quot;dotnet&quot;, &quot;DockerDemo.dll&quot;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>设置Dockerfile的文件属性为始终复制，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142349155.webp" alt="图片" loading="lazy"></p><p>以文件系统的形式发布项目，指定本地目录，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142349034.webp" alt="图片" loading="lazy"></p></li><li><p>将发布之后的文件拷贝到装有Docker的主机上</p><p>将项目进行发布，把发布之后的文件拷贝到我的阿里云服务器上，用到的工具是FinalShell(一个工具完成连接服务器和上传文件，很好用)，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142349420.webp" alt="图片" loading="lazy"></p></li><li><p>打包为镜像</p><p>进入发布文件目录，执行<code>docker build</code>命令，将发布文件打包为一个镜像，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142349513.webp" alt="图片" loading="lazy"></p><p>上图中的mydockerdemo 是镜像名，可以自定义；通过<code>docker images</code>查看镜像是否生成，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142349452.webp" alt="图片" loading="lazy"></p></li><li><p>根据镜像启动容器(里面包含我们的项目)</p><p>镜像生成之后，就可以通过<code>docker run</code>指令根据镜像启动容器了，即启动我们的项目</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142349716.webp" alt="图片" loading="lazy"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker run -d --name mydockerdemo -p 9999:80 mydockerdemo
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>-d：后台模式运行；</p><p>--name：给运行中的容器指定一个名字；</p><p>-p：指定端口映射， 主机的端口9999映射到容器的端80，因为在容器里面我们的项目是以80 端口启动的；</p><p>最后一个参数是上一步生成的镜像名称， 即根据此镜像启动一个容器实例。</p></li><li><p>测试访问看看，只要配置了云服务器的安全组和防火墙放开9999端口，那么外网就可以访问了,如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142349630.webp" alt="图片" loading="lazy"></p></li></ul><p>可能有小伙伴说，也挺麻烦的；其实编写Dockerfile，打包镜像等操作都是一次性的，只要生成了镜像，后续其他环境直接根据镜像启动即可，不用再单独安装.NetCore运行时等基础设施了，打包好的镜像里包含了完整的运行环境。</p><h1 id="_4-常用命令" tabindex="-1"><a class="header-anchor" href="#_4-常用命令" aria-hidden="true">#</a> 4. 常用命令</h1><h2 id="_4-1-预览" tabindex="-1"><a class="header-anchor" href="#_4-1-预览" aria-hidden="true">#</a> 4.1 预览</h2><p>Docker和我们熟悉的Git很类似，都是通过命令执行相关操作，当然也有一些界面管理工具(点按钮的那种)，但大家似乎更喜欢直接敲命令，毕竟这种方式更加灵活、更加容易理解操作本质；有大神将常用命令用一张图很好的展现出来，这里借用一下(图片来源于网络，侵删)：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142349168.webp" alt="图片" loading="lazy">cmd_logic</p><p>不熟悉Docker的小伙伴可能看见这图直接懵圈了，别急，接着往下看， 看完再回过头来瞅这张图，绝对感觉很给力。</p><h2 id="_4-2-常用命令实操" tabindex="-1"><a class="header-anchor" href="#_4-2-常用命令实操" aria-hidden="true">#</a> 4.2 常用命令实操</h2><h3 id="_4-2-1-全局命令" tabindex="-1"><a class="header-anchor" href="#_4-2-1-全局命令" aria-hidden="true">#</a> 4.2.1 全局命令</h3><ul><li><p><strong><code>docker version</code></strong>：查看docker版本信息。</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142349190.webp" alt="图片" loading="lazy"></p></li><li><p><strong><code>docker info</code></strong>：查看docker详情信息，比如仓储信息、加速器配置信息、有多少个镜像、有多少个容器、CPU、内存等。</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142349901.webp" alt="图片" loading="lazy"></p></li><li><p><strong><code>docker events</code></strong>：从docker 服务获取实时事件，通俗一点理解就是操作日志，比如对镜像、容器、网络、挂载卷等操作，就会记录对应的事件信息；<strong>最多能返回最近的1000条日志信息</strong>。</p><p>先在一个终端执行命令，终端会阻塞：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142349995.webp" alt="图片" loading="lazy"></p><p>开启另一个终端，执行根据镜像运行容器的命令：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142349306.webp" alt="图片" loading="lazy"></p><p>此时开启的第一个终端就实时输出事件消息，如镜像拉取、容器启动、容器结束等信息，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142349435.webp" alt="图片" loading="lazy"></p><p>既然可以把这个命令当做操作日志理解，那肯定可以根据条件查看对应的数据，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142349218.webp" alt="图片" loading="lazy"></p><p>如图所示，会先显示符合条件的事件信息，然后会继续阻塞，如果对服务端有操作，信息还会实时显示。常用的参数指定如下：</p><p><strong>-f</strong> ：根据条件过滤事件，如上图指定的是镜像为hello-world相关的事件信息；</p><p><strong>--since</strong> ：从指定的时间戳后显示所有事件，可以理解为开始时间，支持多种时间格式，默认使用本地主机的时区;</p><p><strong>--until</strong> ：显示到指定的时间为止，可以理解为结束时间；</p></li></ul><h3 id="_4-2-2-镜像常用命令" tabindex="-1"><a class="header-anchor" href="#_4-2-2-镜像常用命令" aria-hidden="true">#</a> 4.2.2 镜像常用命令</h3><p><strong>镜像(image)可以理解为一种轻量级、可独立运行的软件包，包含了应用程序及其他运行需要的基础设施</strong>，如运行时、配置文件、依赖的库等，所以没有镜像就没法启动容器；就好比开发中没有类(class)，又怎么去根据类创建实例呢。</p><p><strong>镜像是只读的</strong>，所以操作命令不多，一般就是增、删、查。</p><ul><li><p><strong><code>docker images</code></strong>：列出Docker主机上的镜像</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142349162.webp" alt="图片" loading="lazy"></p><p>可以指定参数，比较常用的如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142349102.webp" alt="图片" loading="lazy"></p><p><strong>-a</strong> :列出本地所有的镜像（含中间镜像层，默认过滤掉中间镜像层）。</p><p><strong>-q</strong> :只显示镜像ID。</p><p><strong>上图中的-aq就是显示所有镜像的ID，一般用于批量删除</strong>。</p></li><li><p><strong><code>docker search</code></strong>：从远程仓储中搜索镜像，后面直接根镜像名称即可</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142349501.webp" alt="图片" loading="lazy"></p><p>可以指定条件进行搜索，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142349973.webp" alt="图片" loading="lazy"></p><p><strong>--filter</strong>：指定条件搜索，<strong>is-official表示是否为官方的，stars表示要找多少星星以上的</strong>。</p><p>对于搜索，我还是比较喜欢用界面，直观好看：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142349881.webp" alt="图片" loading="lazy"></p></li><li><p><strong><code>docker pull</code></strong>：从远程仓储中拉取镜像，<strong>后面跟镜像名和tag即可，即指定版本拉取，如果不指定tag，默认就latest，最新的</strong>。</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142350147.webp" alt="图片" loading="lazy"></p><p><strong>镜像的分层原理就是采用UnionFS(联合文件系统)，是一种分层、轻量级的高性能文件系统；镜像可以通过分层来进行继承，可以基于基础镜像制作出各种具体的应用镜像</strong>，比如我们刚拉取下来的nginx镜像，这里先了解，后续我们自己制作镜像的时候就明白了。</p><p><strong><code>docker pull 镜像名:tag</code></strong>：指定版本拉取；</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142350426.webp" alt="图片" loading="lazy"></p></li><li><p><strong><code>docker rmi</code></strong>：删除指定镜像，后面可以跟名称或镜像ID</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142350774.webp" alt="图片" loading="lazy"></p><p>删除指定版本，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142350704.webp" alt="图片" loading="lazy"></p><p>根据镜像ID删除，可以一下删除多个，中间用空格隔开：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142350453.webp" alt="图片" loading="lazy"></p><p>删除全部镜像，就是找出所有镜像ID，然后删除就行了，当然肯定不是一个一个的拷贝镜像ID；**<code>docker images -aq</code>**可以显示所有镜像ID ，所以两个命令结合用即可，如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker rmi -f $(docker images -aq)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>-f</strong>：代表强制删除，比如一些镜像和容器有依赖，会提示不能直接删除，加上这个选项就可以强制删除。</p></li><li><p><strong><code>docker save</code></strong>：导出镜像，可以离线拷贝到其他主机上使用，避免没有网络不能下载镜像的场景。</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142350204.webp" alt="图片" loading="lazy"></p><p>生成的tar文件就可以根据需要拷贝到对应设备上加载使用，不用在线拉取，因为很多场景是不允许连外网的。</p></li><li><p><strong><code>docker load</code></strong>：加载镜像，根据拷贝过来的tar文件可以直接加载镜像到主机上。</p><p>这里演示就将原来拉取的镜像删除，然后通过load命令重新加载，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142350575.webp" alt="图片" loading="lazy"></p><p>加载镜像，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142350478.webp" alt="图片" loading="lazy"></p><p>换一种写法，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142350609.webp" alt="图片" loading="lazy"></p><p>选项说明：</p><p><strong>--input , -i</strong> : 指定导入的文件。</p><p><strong>--quiet , -q</strong> : 简化输出信息，不显示具体加载过程。</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142350865.webp" alt="图片" loading="lazy"></p><p>注：这里因为是在TestDockerImage目录下执行命令，所以指定tar的文件时，就在当前目录下。</p></li></ul><h3 id="_4-2-3-容器常用命令" tabindex="-1"><a class="header-anchor" href="#_4-2-3-容器常用命令" aria-hidden="true">#</a> 4.2.3 容器常用命令</h3><p><strong>容器是用镜像创建的运行实例，</strong> 它可以被启动、开始、停止、删除，<strong>每个容器都是相互隔离</strong>；可以把容器看做是一个极简版的Linux环境和在其中运行程序的组合；</p><p><strong>容器</strong>和镜像几乎一样，唯一的区别就是<strong>镜像层上面加载了一个可写层</strong>，这层称为<strong>容器层</strong>；</p><p>以下对容器的操作，可以指定容器名称，也可以指定容器ID，演示统一用容器ID，不再重复截图。</p><ul><li><p><strong><code>docker run</code></strong>：根据镜像启动容器；语法如下：<code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code>;</p><p>常用选项参数说明，如下：</p><p><strong>--name=&quot;容器名&quot;</strong> : 为容器指定一个名称；</p><p><strong>-d</strong>: 后台运行容器，并返回容器ID；</p><p><strong>-i</strong>: 以交互模式运行容器，一般和 -t 同时使用；</p><p><strong>-t</strong>: 为容器重新分配一个伪输入终端，一般和 -i 同时使用；</p><p><strong>-P</strong>: 随机端口映射，容器内部端口<strong>随机</strong>映射到主机的端口</p><p><strong>-p</strong>: 指定端口映射，格式为：<strong>主机端口:容器端口</strong></p><p>演示如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142350825.webp" alt="图片" loading="lazy"></p><p>上图可以看到终端阻塞了，<strong>这种模式称为attached默认，即前台运行，与之对应的是detached模式，及后台运行</strong>，接下来会演示。由于终端阻塞，这里另开一个终端执行<code>docker ps</code>命令看运行的容器，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142350553.webp" alt="图片" loading="lazy"></p><p><strong>前台运行模式终端很容易被关闭，启动的nginx容器也会停掉</strong>，这种情况对于很多场景是不允许的，所以可以指定为后台模式运行，即detached模式，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142350059.webp" alt="图片" loading="lazy"></p><p>现在只是在容器内启动了一个nginx，并监听80端口，如果需要通过主机能访问到容器里面的nginx，还需进行端口映射，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142350203.webp" alt="图片" loading="lazy"></p><p>这里启动了两个nginx容器，都是监听80端口，但并没有报端口被占用的错，所以容器之间是互不影响的。通过**-p**选项进行端口映射，这下就可以通过主机的9999端口访问到容器内部的80端口，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142350729.webp" alt="图片" loading="lazy"></p><p>既然刚开始说可以将容器理解为简易版的Linux，那就应该可以进入容器内部操作一把，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142350452.webp" alt="图片" loading="lazy"></p><p>在容器里面只能执行一些核心的命令，因为是极简版，所以内部只包含重要的功能，如果需要其他功能可以自己安装扩展。</p><p><strong>退出容器的两种方式：</strong></p><p>a、容器中执行<strong>exit</strong>命令，容器停止并退出，回到主机；</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142350090.webp" alt="图片" loading="lazy"></p><p>b、利用组合键<strong>ctrl+p+q</strong>，容器不停止退出，回到主机；</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142350887.webp" alt="图片" loading="lazy"></p></li><li><p><strong><code>docker ps [OPTIONS]</code></strong> ：显示主机中的容器，不加选项<strong>默认只列出运行中的容器</strong>；</p><p><strong>-a :</strong> 显示所有的容器，包括未运行的；</p><p><strong>-n :</strong> 列出最近创建的n个容器；</p><p>演示如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142351041.webp" alt="图片" loading="lazy"></p></li><li><p>启动和停止容器的命令；</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker start 容器id  # 启动被停止的容器
docker stop 容器id  # 停止运行中的容器
docker restart 容器id # 重启容器
docker kill 容器id  # 强制停止容器
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**<code>docker stop</code>**停止容器，后面可以跟一个或多个容器ID：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142351132.webp" alt="图片" loading="lazy"></p><p><strong><code>docker start</code></strong>：启动被停止的容器，后面可以跟一个或多个容器ID：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142351343.webp" alt="图片" loading="lazy"></p><p>**<code>docker restart</code><strong>重启命令和</strong><code>docker kill</code>**强制停止命令就不截图啦</p></li><li><p>**<code>docker exec</code>和<code>docker attach</code>**两种方式进入正在运行的容器。</p><p>很多场景容器都是后台运行，但有时需要进入容器内部进行相关配置的更改。</p><p><strong><code>docker exec</code></strong>：进入容器后开启一个新的终端，正常执行Linux相关命令。</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142351161.webp" alt="图片" loading="lazy"></p><p><strong><code>docker attach</code></strong>：进入容器正在执行的终端，不会启动新的进程。</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142351590.webp" alt="图片" loading="lazy"></p><p>退出容器模式：</p><p><strong>容器中执行exit命令，容器停止并退出;</strong></p><p><strong>利用组合键ctrl+p+q，容器不停止退出;</strong></p></li><li><p><strong><code>docker logs [OPTIONS] 容器ID</code></strong>：查看指定容器的日志；</p><p>常用OPTIONS如下：</p><p><strong>-f</strong> :跟踪日志输出</p><p><strong>--since</strong> :显示指定开始时间之后所有日志</p><p><strong>-t</strong> : 显示时间戳</p><p><strong>--tail</strong> :列出最新N条容器日志</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142351326.webp" alt="图片" loading="lazy"></p><p>可以指定选项，查看需要的日志，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142351153.webp" alt="图片" loading="lazy"></p></li><li><p><strong><code>docker top 容器ID</code></strong>：列出指定容器内部的进程，可以看到容器内的应用进程是否正常运行，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142351224.webp" alt="图片" loading="lazy"></p></li><li><p><strong><code>docker inspect 容器ID</code></strong>：查看指定容器的详细信息，比如运行状态、网络配置、挂载的卷等信息都有，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142351638.webp" alt="图片" loading="lazy"></p></li><li><p><strong><code>docker commit</code>：根据容器生成一个新的镜像</strong>；容器是可编辑的，有些时候需要将已更改的容器生成一个新的镜像给其他人用。</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142351917.webp" alt="图片" loading="lazy"></p><p>命令说明：</p><p><strong>-a</strong> :提交的镜像作者；</p><p><strong>-m</strong> :提交时的说明文字；</p><p>命令中<strong>testcommitimage:v1</strong>是自定义的镜像名和tag；</p><p>根据新生成的镜像启动容器，则内部就会有创建的对应文件(容器内部可以根据需要任意改，这里只是演示创建文件而已)。</p></li><li><p>**<code>docker export</code>和<code>docker import</code>**将容器方便离线导出和导入；</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142352257.webp" alt="图片" loading="lazy"></p><p>命令说明：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>#将容器导出为tar文件
docker export -o testexport.tar 030aa6fcd7f3
# -o 指定输出位置和文件名
# 030aa6fcd7f3 这个是容器ID

#根据生成的tar文件导入为镜像
docker import testexport.tar testexportimagename:v2
# 指定对应的tar文件
# testexportimagename:v2 镜像名和版本, 可以自己定义
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这对命令是不是和镜像的<code>docker save</code>、<code>docker load</code>这对命令用法很相似，但两种方式不能混用，因为export导出的仅仅是容器快照，save保存的是完整的镜像文件。</p></li><li><p><strong><code>docker rm 容器ID</code></strong>：删除指定容器，运行中的容器默认不让删除，可以增加**-f选项**强制删除，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142352768.webp" alt="图片" loading="lazy"></p></li></ul>`,33),u={href:"https://docs.docker.com/engine/reference/commandline/rm/%EF%BC%9B",target:"_blank",rel:"noopener noreferrer"},b=e("h1",{id:"_5-数据卷",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_5-数据卷","aria-hidden":"true"},"#"),t(" 5. 数据卷")],-1),h=e("p",null,[t("常用命令演示了一遍，其中也提到容器的隔离性，"),e("strong",null,"默认情况下，容器内应用产生的数据都是由容器本身独有，如果容器被删除，对应的数据文件就会跟着消失"),t("。从隔离性的角度来看，数据就应该和容器共存亡；但在实际用场景中，更多需要将数据持久化，即容器被删除，数据也应该正常存在；另外也有很多场景需要容器之间共享数据，那该怎么做呢，接下来说说容器数据卷。")],-1),v=e("h2",{id:"_5-1-手动保存数据",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_5-1-手动保存数据","aria-hidden":"true"},"#"),t(" 5.1 手动保存数据")],-1),k=e("p",null,"通常手动有两种方式，一是通过命令就行拷贝，二是将容器提交为镜像。接下来通过拉取centos镜像，运行演示",-1),x=e("p",null,[e("strong",null,"通过命令形式")],-1),w=e("p",null,"主机和容器之间可以通过命令进行数据拷贝，也就是说，在容器删除之前可以先进行数据拷贝，如下：",-1),_=e("p",null,[e("img",{src:"https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142352083.webp",alt:"图片",loading:"lazy"})],-1),f=e("code",null,'docker run -it --name="mycentos" centos /bin/bash',-1),y={href:"http://mp.weixin.qq.com/s?__biz=MzU1MzYwMjQ5MQ==&mid=2247485629&idx=1&sn=506fae15e0c583f0a76d5c4145dbf83a&chksm=fbf11469cc869d7fae9c795ecf099a0babb62094fcb5b94b361ca131ae0323f57f46f55e79e3&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"},D=a('<p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142352158.webp" alt="图片" loading="lazy"></p><p>上图简述：<strong>在Docker执行启动命令时，会先从本地查找镜像，如果没有，就会去远程仓库搜索并拉取到主机，然后主机就可以根据镜像启动容器；如果远程仓库也没有找到镜像，那么就报错</strong>。</p><p>好了，回到今天的话题，接着说拷贝数据；</p><p>现在通过centos镜像启动了一个容器(Linux系统)，在上面创建一些文件进行测试，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142352348.webp" alt="图片" loading="lazy"></p><p>现在如果将容器删除，里面对应的数据也会删除，所以需要将对应的数据拷贝到主机上，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142352999.webp" alt="图片" loading="lazy"></p><p><code>docker cp bfb96a6afdbc:/usr/TestData /usr/TestDataHost</code>命令解析:</p>',8),R=a('<li><p>语法：<strong>docker cp SRC_PATH DEST_PATH</strong></p></li><li><p><strong>bfb96a6afdbc:/usr/TestData</strong>对应的就是<strong>SRC_PATH</strong> ，表示源头，即需要拷贝的目录或文件；<strong>bfb96a6afdbc</strong>这是容器ID，通过这种方式限定是某个容器内的数据文件；</p></li><li><p><strong>/usr/TestDataHost</strong>对应的就是<strong>DEST_PATH</strong>，表示目标，即拷到什么地方；</p><p>按照上面的语法规则，同样可以将主机上的数据文件拷贝到指定容器中，只是调换一下<strong>SRC_PATH</strong> 和<strong>DEST_PATH</strong>的位置即可，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142352762.webp" alt="图片" loading="lazy"></p></li><li><p><strong>将容器提交为镜像的方式</strong></p><p>这种方式只能勉强说是一种备份，只是<strong>通过<code>docker commit</code>命令将容器提交为镜像，从而达到备份数据的作用</strong>；</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142352014.webp" alt="图片" loading="lazy"></p><p>但很明显能感觉到不灵活，数据还是在容器内。关于<code>docker commit</code>命令上次已经说过，这里就不重复截图啦。</p></li>',4),N=a(`<p>以上两种方式都不是很好的选择，首先在时效上也不能及时备份，另外通过手动这种操作很明显效率不高，还容易出错；更重要的是苦了小伙伴们，所以必须把自动安排起来；手动这种方式，根据情况偶尔用用就可以啦。</p><h2 id="_5-2-容器数据卷解放双手" tabindex="-1"><a class="header-anchor" href="#_5-2-容器数据卷解放双手" aria-hidden="true">#</a> 5.2 容器数据卷解放双手</h2><h3 id="_5-2-1-简单理解容器数据卷" tabindex="-1"><a class="header-anchor" href="#_5-2-1-简单理解容器数据卷" aria-hidden="true">#</a> 5.2.1 简单理解容器数据卷</h3><p><strong>数据卷可以理解为目录或文件，设计目的就是为了数据的持久化和共享</strong>；</p><p><strong>挂载数据卷的容器，称为数据卷容器</strong>；数据卷完全独立于容器的生存周期，所以容器删除时，对应挂载的数据卷不会被删除。</p><p><strong>通过将容器内的目录挂载到主机上面，就可以让数据实时同步，不管是主机改动，还是容器里有变动，都会同步更新</strong>。</p><h3 id="_5-2-2-实操演示" tabindex="-1"><a class="header-anchor" href="#_5-2-2-实操演示" aria-hidden="true">#</a> 5.2.2 实操演示</h3><p>这里先用命令的方式进行演示，关于Dockerfile中的应用会在后续的章节中说到。</p><p><code>docker run</code>命令中**-v**的选项在上次没说，就是故意留到这里单独分享；直接在启动容器的时候挂载；语法主要有如下几种方式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># 指定具体的主机路径和容器内的路径
docker run -v /宿主机路径:容器内路径 镜像名  
# 指定容器内的路径，docker默认自动指定主机路径
docker run -v 容器内路径 镜像名 
# 指定容器内的路径，并指定一个名字，主机路径docker自动指定
docker run -v 卷名:容器内路径 镜像名 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><strong>匿名挂载</strong>：在挂载时不指定名称，会自动生成一个名称</p><p><strong>指定主机目录</strong></p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142352943.webp" alt="图片" loading="lazy"></p><p>命令解析如下图：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142352892.webp" alt="图片" loading="lazy"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># docker run -it --name=&quot;容器名称&quot; -v 主机绝对路径:容器绝对路径 镜像名称
docker run -it --name=&quot;TestVolumeCentos&quot; -v /usr/TestDataHost/DataVolumeTest:/usr/TestVolumeData centos
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>现在已经将容器内的目录挂载到主机上，接下来感受一下数据同步：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142352276.webp" alt="图片" loading="lazy"></p><p>通过上图演示可以看到，<strong>不管是在主机还是在容器中修改数据，都能及时同步更新；容器停止之后，主机更新数据，容器再启动，修改的数据也会同步到容器；容器删除，挂载的数据不会被删除，还是在主机中</strong>，这就是我们想要的。</p><p>可以通过<code>docker inspect 容器</code>命令查看容器的详细信息，其中就有挂载卷的详细信息，如下部分截图：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142352106.webp" alt="图片" loading="lazy"></p><p><strong>不指定主机目录</strong></p><p>很多时候，我们不喜欢自己指定主机目录，而是由Docker自动指定，所以通常我们只指定容器内目录，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142352274.webp" alt="图片" loading="lazy"></p><p>看看Docker指定的主机路径在哪，还是通过<code>docker inspect 容器ID</code>查看详情，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142352103.webp" alt="图片" loading="lazy"></p><p>看看刚才在容器操作的文件数据是否同步过来：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142352927.webp" alt="图片" loading="lazy"></p><p>默认情况，docker都会将挂载的主机目录指定到如上图的目录中。</p><p>可以通过<code>docker volume ls</code>查看主机挂载的数据卷信息，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142352316.webp" alt="图片" loading="lazy"></p><p>通过上图可以看到，名称不直观，看不懂，所以更多时候都会在挂载的时候指定一个名称，即具名挂载。</p></li><li><p><strong>具名挂载</strong>：在挂载时指定一个名称。</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142352967.webp" alt="图片" loading="lazy"></p><p>这里除了挂载的时候是指定名称挂载，之后的操作和效果都一样，这里就不重复截图了；需要注意的是这种方式和指定主机的命令很像，指定路径那种形式，冒号前面是路径，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142352693.webp" alt="图片" loading="lazy">image-20210825175448280</p></li></ul><h3 id="_5-2-3-容器间传递数据" tabindex="-1"><a class="header-anchor" href="#_5-2-3-容器间传递数据" aria-hidden="true">#</a> 5.2.3 容器间传递数据</h3><p><strong>数据卷其实还可以通过容器继承方式进行挂载，从而实现容器之间的数据共享</strong>，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142353481.webp" alt="图片" loading="lazy"></p><p>关键命令解析：</p><ul><li><p>先启动一个具名挂载的容器TestVolumesFromCentos，如下命令：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker run -it --name=&quot;TestVolumesFromCentos&quot; -v testVolumesFrom:/usr/TestVolumeData centos
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>在启动另一个容器TestVolumesFromCentos2，挂载卷继承于TestVolumesFromCentos，如下命令：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker run -it --name=&quot;TestVolumesFromCentos2&quot; --volumes-from TestVolumesFromCentos centos
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>--volumes-from 后指定继承于哪个容器</strong>。</p></li></ul><p>现在不管在哪个容器中变更数据，都会实时同步到其他容器中，从而达成了容器数据的共享和实时同步。</p><p>通过<code>docker inspect 容器ID</code>看两个容器的挂载详情都一样，截其中一个容器如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142353533.webp" alt="图片" loading="lazy"></p><p>其实在指定挂载的时候还可以限制容器的操作权限，比如在容器内的挂载目录下，可以限制容器内只读或可读写，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142353148.webp" alt="图片" loading="lazy"></p><p><strong>ro：代表只读；</strong></p><p><strong>rw：代表读写；</strong></p><p>好了，关于容器数据卷就说到这吧，是不是听起来名字高大上，其实就是对文件或目录的操作。</p><h3 id="_5-2-4-redis安装实战" tabindex="-1"><a class="header-anchor" href="#_5-2-4-redis安装实战" aria-hidden="true">#</a> 5.2.4 redis安装实战</h3><p>关于Redis安装在Docker中很简单，直接执行命令即可，由于之前拉取过redis的镜像，所以就直接启动容器了，如果本地没有镜像，就会去远程仓库拉取。</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142353297.webp" alt="图片" loading="lazy"></p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142353537.webp" alt="图片" loading="lazy"></p><p>上图中可以看到，默认情况下，redis的镜像将容器内的/data目录挂载到这个主机上，而这个目录就是redis数据存放的目录，这样就达到Redis的持久化。</p><p>对于Redis而言，很多时候需要修改配置文件，总不能每次修改都要到容器内更改，我们可以将配置文件放在已挂载的目录中，然后指定启动，也可以另外针对配置文件再加一个挂载，如下：</p><p><strong>执行命令前，需要将配置文件提前放在主机的这个/usr/TestDataHost/redisconf目录中</strong>。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker run -d -v /usr/TestDataHost/redisconf:/usr/local/etc/redis --name myredisconfigtest redis redis-server /usr/local/etc/redis/redis.conf
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通过<code>docker inspect 容器</code>看看挂载情况，如下：</p><p>通过挂载之后，如果需要修改配置文件，只需要在主机上修改配置文件内容即可。</p><h1 id="_6-dockerfile解析" tabindex="-1"><a class="header-anchor" href="#_6-dockerfile解析" aria-hidden="true">#</a> 6. Dockerfile解析</h1><p>使用第三方镜像肯定不是学习Docker的最终目的，最想要的还是自己构建镜像；将自己的程序、文件、环境等构建成自己想要的应用镜像，方便后续部署、启动和维护；而Dockerfile就是专门做这个事的，通过类似简单编码的形式，最终就可以构建出属于自己的镜像，所以必须学起来。</p><h2 id="_6-1-dockerfile简介" tabindex="-1"><a class="header-anchor" href="#_6-1-dockerfile简介" aria-hidden="true">#</a> 6.1 Dockerfile简介</h2><p>在日常开发过程中，需要编写对应的程序文件，最后通过编译打包生成对应的可执行文件或是类库；这里的Dockerfile文件就好比平时我们编写的程序文件，但内部的语法和关键字并没有程序那么复杂和繁多，相对来说还是很简单的，最后通过<code>docker build</code>命令就可以将对应的程序、文件、环境等构建成镜像啦。</p><p>在第一篇文章最后就简单使用了Dockerfile构建了一个镜像，这里重新认识下这个Dockerfile文件，如下图：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142353887.webp" alt="图片" loading="lazy"></p><p><strong>Dockerfile就是一个文本文件</strong>，但不需要指定后缀类型；文件内容中FROM、WORKDIR、COPY等就是关键字，按照规则写好之后，就可以将指定的文件构建为镜像啦。</p><p><strong>构建操作统一由Docker daemon进行，它会先对文件内容语法进行初步验证(语法不对就会返回错误信息)，然后逐一运行指令，每次生成一个新的镜像层，直到执行完所有指令，就构建出最终的镜像。</strong> Dockerfile、镜像、容器的关系如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142353109.webp" alt="图片" loading="lazy"></p><p>总结一下Dockerfile的知识点；</p><ul><li><strong>构建时，指令从上到下逐一执行；</strong></li><li><strong>每条指令都会创建一个新的镜像层，每一层都是前一层变化的增量；</strong></li><li><strong>使用#号进行注释；</strong></li><li><strong>关键字约定都是大写，后面至少跟一个参数；</strong></li></ul><h2 id="_6-2-dockerfile关键字" tabindex="-1"><a class="header-anchor" href="#_6-2-dockerfile关键字" aria-hidden="true">#</a> 6.2 Dockerfile关键字</h2><h3 id="_6-2-1-from-关键字" tabindex="-1"><a class="header-anchor" href="#_6-2-1-from-关键字" aria-hidden="true">#</a> 6.2.1 FROM 关键字</h3><p><strong>指定基础镜像</strong>， 就是新镜像是基于哪个镜像构建的。</p><p>比如建房子，可以在一块空地开始，也可以在别人打好的基石基础上开始， 甚至可以在别人弄好的毛坯房基础上装修即可。</p><p>如果要建房的话，可以FROM 空地，或者FROM 打好的基石，或者 FROM 毛坯房， 反正最后建好房就行；</p><p>这里需要注意的是，不管咋样，空地是少不了的；<strong>构建镜像也一样，最底层肯定有一个最基础的镜像</strong>。</p><p>建议使用官方的镜像作为基础镜像，推荐使用Alpine这种类型，因为它是严格控制的，而且体积很小。</p><p>用法如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> # FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]
 ARG  CODE_VERSION=latest # 定义变量
 FROM base:\${CODE_VERSION} # 指定基础镜像
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-2-2-maintainer-label-关键字" tabindex="-1"><a class="header-anchor" href="#_6-2-2-maintainer-label-关键字" aria-hidden="true">#</a> 6.2.2 MAINTAINER/LABEL 关键字</h3><p><strong>MAINTAINER 指定维护者的相关信息，也就是构建的镜像是由谁构建的，他的邮箱是什么</strong>；</p><p><strong>LABLE 就是用于给镜像打标签，以键值对的方式进行指定</strong>，相对MAINTAINER 来说比较灵活，可以使用LABLE替代MAINTAINER。</p><p>用法如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> # LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...
 LABEL com.example.version=&quot;0.0.1-beta&quot; 
 LABEL vendor1=&quot;ACME Incorporated&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-2-3-run-关键字" tabindex="-1"><a class="header-anchor" href="#_6-2-3-run-关键字" aria-hidden="true">#</a> 6.2.3 RUN 关键字</h3><p><strong>构建过程中需要运行的命令</strong>， 比如在构建过程中需要执行一条命令下载对应的包，这里就需要用到RUN关键字；</p><p>用法如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> # 两种命令方式都可以
 # RUN &lt;command&gt;
 # RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]
 # 执行命令,Linux支持的相关命令
 RUN /bin/bash -c &#39;source $HOME/.bashrc; echo $HOME&#39;
 RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-2-4-workdir-关键字" tabindex="-1"><a class="header-anchor" href="#_6-2-4-workdir-关键字" aria-hidden="true">#</a> 6.2.4 WORKDIR 关键字</h3><p>根据镜像启动容器时，通常需要进入到容器内部；<strong>则可以通过WORKDIR指定进入容器时的目录</strong>；</p><p>用法如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> WORKDIR /path # 指定路径
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_6-2-5-env-关键字" tabindex="-1"><a class="header-anchor" href="#_6-2-5-env-关键字" aria-hidden="true">#</a> 6.2.5 ENV 关键字</h3><p>可以在构建过程中设置环境变量；就好比平时我们安装完程序，需要配置环境变量，方便访问；ENV关键字就是根据需求可以设置对应的环境变量；</p><p>用法如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> # ENV &lt;key&gt;=&lt;value&gt; ...
 # 指定环境变量
 ENV PATH=/usr/local/postgres-$PG_MAJOR/bin:$PATH
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-2-6-add-关键字" tabindex="-1"><a class="header-anchor" href="#_6-2-6-add-关键字" aria-hidden="true">#</a> 6.2.6 ADD 关键字</h3><p><strong>将宿主机的资源拷贝进镜像中，会自动解压缩，而且还能从远程宿主机中读取资源并拷贝到镜像中</strong>；</p><p>用法如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> # 两种命令方式都可以
 # ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;
 # ADD [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]
 ADD https://example.com/big.tar.xz /usr/src/things/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-2-7-copy-关键字" tabindex="-1"><a class="header-anchor" href="#_6-2-7-copy-关键字" aria-hidden="true">#</a> 6.2.7 COPY 关键字</h3><p><strong>将宿主机的资源拷贝到镜像中，只支持读取构建所在宿主机的资源</strong>。相对于ADD关键字来说更加透明，操作什么就是什么。</p><p>用法如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> # 拷贝资源到容器，两种命令格式都行
 # COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源地址&gt;... &lt;目标地址&gt;
 # COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源地址&gt;&quot;,... &quot;&lt;目标地址&gt;&quot;]
 COPY requirements.txt /tmp/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-2-8-volume-关键字" tabindex="-1"><a class="header-anchor" href="#_6-2-8-volume-关键字" aria-hidden="true">#</a> 6.2.8 VOLUME 关键字</h3><p>挂载数据卷，之前在常用命令那说到通过命令的方式进行数据卷挂载，在Dockerfile中使用<strong>VOLUME</strong>指定挂载路径即可，根据构建出来的镜像运行容器时，默认就有构建时挂载的信息。</p><p>用法如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> # 挂载数据卷
 VOLUME [&quot;/data&quot;]
 VOLUME /myvol
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-2-9-expose-关键字" tabindex="-1"><a class="header-anchor" href="#_6-2-9-expose-关键字" aria-hidden="true">#</a> 6.2.9 EXPOSE 关键字</h3><p>指定运行容器时对外暴露的端口；即根据镜像启动容器时，容器向外暴露端口。</p><p>用法如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> # EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]
 EXPOSE 80/tcp # 暴露端口
 EXPOSE 80/udp
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-2-10-cmd-关键字" tabindex="-1"><a class="header-anchor" href="#_6-2-10-cmd-关键字" aria-hidden="true">#</a> 6.2.10 CMD 关键字</h3><p>指定启动容器时要执行的命令，只有最后一个会生效；即根据镜像启动容器时，容器需要执行啥命令。</p><p>用法如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> # 两种格式都行
 # CMD [&quot;param1&quot;,&quot;param2&quot;]
 # CMD command param1 param2
 # 执行命令统计 行数、字数、字节数
 CMD echo &quot;This is a test.&quot; | wc -
 # 执行wc --help命令 
 CMD [&quot;/usr/bin/wc&quot;,&quot;--help&quot;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-2-11-entrypoint-关键字" tabindex="-1"><a class="header-anchor" href="#_6-2-11-entrypoint-关键字" aria-hidden="true">#</a> 6.2.11 ENTRYPOINT 关键字</h3><p>指定根据镜像启动容器时要执行的命令，可以追加命令；执行时机同CMD。</p><p>用法如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> # ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]
 # ENTRYPOINT command param1 param2
 ENTRYPOINT [&quot;top&quot;, &quot;-b&quot;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-2-12-arg-关键字" tabindex="-1"><a class="header-anchor" href="#_6-2-12-arg-关键字" aria-hidden="true">#</a> 6.2.12 ARG 关键字</h3><p>通过ARG指令定义了一个变量；和写代码时定义的变量一样，根据需要，定义就行啦。</p><p>用法如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> # ARG &lt;name&gt;[=&lt;default value&gt;]
 ARG user1=someuser
 ARG buildno=1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-2-13-onbuild-关键字" tabindex="-1"><a class="header-anchor" href="#_6-2-13-onbuild-关键字" aria-hidden="true">#</a> 6.2.13 ONBUILD 关键字</h3><p>基于父镜像构建新的镜像时，父镜像的OBUILD会被触发。</p><h2 id="_6-3-实战演示" tabindex="-1"><a class="header-anchor" href="#_6-3-实战演示" aria-hidden="true">#</a> 6.3. 实战演示</h2><p>这里还是以.NetCore项目构建镜像为例，其他编程语言的项目同理；这次咱们一步一步的来，搞清楚每个命令的使用。</p>`,103),A={href:"https://mp.weixin.qq.com/s?__biz=MzU1MzYwMjQ5MQ==&mid=2247485538&idx=1&sn=1a264b5b0cb9577ddbc10dbfdf529298&chksm=fbf114b6cc869da08a707988d885f4ce99d4cf3aac57749b6b37fcf407189ae312acb0174077&token=583695816&lang=zh_CN&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"},q=a(`<h3 id="_6-3-1-准备项目和dockerfile文件" tabindex="-1"><a class="header-anchor" href="#_6-3-1-准备项目和dockerfile文件" aria-hidden="true">#</a> 6.3.1 准备项目和Dockerfile文件</h3><p>新建一个项目，啥都不需要改，就用默认的接口演示，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142353126.webp" alt="图片" loading="lazy"></p><p>Dockerfile内容如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> # 指定基础镜像，在此基础上构建自己的项目镜像
 FROM mcr.microsoft.com/dotnet/core/aspnet:3.1
 # 指定自己的工作目录，进入容器时目录
 WORKDIR /myApp
 # 将构建上下文目录下的文件拷贝到容器的当前工作目录中，即/myApp
 COPY . .
 # 容器向外暴露端口，项目以什么端口启动就暴露对应的端口
 EXPOSE 80
 # 执行命令，这里默认是以80端口启动的
 #就类似于在Linux系统的项目目录下执行 dotnet DockerfileDemo.dll 是一样的
 ENTRYPOINT [&quot;dotnet&quot;, &quot;DockerfileDemo.dll&quot;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>记得右键Dockerfile，选择属性，然后设置Dockerfile为始终复制</strong>，这样后续更新变动，发布时就会自动拷贝到对应的发布目录。</p><h3 id="_6-3-2-发布" tabindex="-1"><a class="header-anchor" href="#_6-3-2-发布" aria-hidden="true">#</a> 6.3.2 发布</h3><p>以文件的形式发布项目，并连同Dockerfile拷贝到安装好Docker的机器上进行构建(这里还是用我的云服务器)；</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142353000.webp" alt="图片" loading="lazy"></p><p><strong><code>docker build -t myimage:v1.0 .</code>解析</strong>：</p><ul><li><strong>-t</strong>：指定镜像的名字及标签，通常 name:tag 或者 name 格式，myimage就是镜像名字，v1.0就是tag；</li><li><strong>-f</strong> :指定要使用的Dockerfile路径，这里由于Dockerfile在当前路径，所以不用指定；</li><li><strong>最后面的点</strong>：<strong>官方称为构建上下文，点表示指定为当前目录</strong>。会把指定的这个目录下的文件发送给docker daemon进行构建，所以千万不要指定/(斜杠代表根目录，有很多文件的)。</li><li>其他选项参数小伙伴可以根据需要使用，以上是比较重要的。</li></ul><h3 id="_6-3-3-启动容器" tabindex="-1"><a class="header-anchor" href="#_6-3-3-启动容器" aria-hidden="true">#</a> 6.3.3 启动容器</h3><p>根据构建出来的镜像启动容器，看Dockerfile中的命令效果；</p><p>启动容器如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142353093.webp" alt="图片" loading="lazy"></p><p><strong><code>ENTRYPOINT [&quot;dotnet&quot;, &quot;DockerfileDemo.dll&quot;]</code>这行代码就等同于的项目目录下直接执行 dotnet DockerfileDemo.dll是一样的，目的就是启动我们的项目</strong>。</p><p>通过<code>docker logs</code>可以查看容器内部的日志，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142353089.webp" alt="图片" loading="lazy"></p><h3 id="_6-3-4-设置dockerfile" tabindex="-1"><a class="header-anchor" href="#_6-3-4-设置dockerfile" aria-hidden="true">#</a> 6.3.4 设置Dockerfile</h3><p>丰富化Dockefile文件内容并查看构建之后的细节</p><p>文件内容如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> # 指定基础镜像，在此基础上构建自己的项目镜像
 FROM mcr.microsoft.com/dotnet/core/aspnet:3.1
 # 指定维护人
 MAINTAINER CodeZYQ&lt;1137533407@qq.com&gt;
 # 打标签
 LABEL createname=&quot;CodeZYQ&quot;
 # 指定自己的工作目录，进入容器时目录 app
 WORKDIR /myapp
 # 将构建上下文目录下的文件拷贝到容器中的工作目录中
 COPY . .
 # 定义变量
 ARG myPort=8080
 # 使用环境变量方式改变启动端口，拼接用到了定义的变量
 ENV ASPNETCORE_URLS=http://+:$myPort
 # 通过RUN 执行相关命令，根据需要执行相关命令
 RUN mkdir testDir
 # 挂载数据卷，这里模拟挂载日志目录
 VOLUME /Logs
 # 容器向外暴露端口，项目以什么端口启动就暴露对应的端口
 EXPOSE $myPort
 # 执行命令，这里默认是以80端口启动的
 # 就类似于在Linux系统的项目目录下执行 dotnet DockerfileDemo.dll 是一样的
 ENTRYPOINT [&quot;dotnet&quot;, &quot;DockerfileDemo.dll&quot;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行如下命令，构建新的镜像：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> # 这里没有显示指定tag 默认就latest
 docker build -t newimage .
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142353154.webp" alt="图片" loading="lazy"></p><p>通过<code>docker logs</code>看看容器日志，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142353565.webp" alt="图片" loading="lazy"></p><p>看看数据卷挂载是否成功，进入容器，看根目录下就会多了Logs目录，也可以通过<code>docker inspect 容器</code> 看容器详细信息，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142353625.webp" alt="图片" loading="lazy"></p><p>标签也打成功了：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142353871.webp" alt="图片" loading="lazy"></p><p>也可以通过<code>docker inspect 镜像</code>查看镜像内部的详细信息，执行命令<code>docker inspect newimage</code>如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142353797.webp" alt="图片" loading="lazy"></p><p>关于步骤和效果，在Dockerfile注释和图表中已经详细描述。</p><h3 id="_6-3-5-cmd和entrypoint的区别" tabindex="-1"><a class="header-anchor" href="#_6-3-5-cmd和entrypoint的区别" aria-hidden="true">#</a> 6.3.5 CMD和ENTRYPOINT的区别</h3><p>两个命令都是启动容器时指定执行命令和对应的参数，但两者稍有不同，如下：</p><ul><li><strong>CMD</strong>：只能最后一个命令会生效，命令会被docker run之后的参数替换掉；</li><li><strong>ENTRYPOINT</strong>：可以追加命令，比如增加参数；</li></ul><p>上面构建出来的newimage镜像用到的是ENTRYPOINT，所以我们先来测试一下ENTRYPOINT，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142353066.webp" alt="图片" loading="lazy"></p><p><code>docker run</code>启动容器时指定了参数 <code>--urls=&quot;http://+:9999&quot;</code>，容器正常启动，并且参数还能生效，等同于在当前目录直接执行如下命令：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> dotnet DockerfileDemo.dll --urls=&quot;http://+:9999&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>现在把ENTRYPOINT换成CMD试试，如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> # 在以上的Dockerfile中
 # 将ENTRYPOINT [&quot;dotnet&quot;, &quot;DockerfileDemo.dll&quot;]换成CMD，如下：
 CMD [&quot;dotnet&quot;, &quot;DockerfileDemo.dll&quot;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后重新构建一个镜像试试，测试如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142353686.webp" alt="图片" loading="lazy"></p><p>如上图，对于CMD而言，如果在运行容器时，后面指定参数，这个参数就会把CMD命令替换掉，不能拼接，导致命令不对，所以报错；但这样就可以执行，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142353155.webp" alt="图片" loading="lazy"></p><p>如果在当前构建的上下文目录中不想要一些文件参与构建，<strong>可以通过在.dockerignore文件中进行配置</strong>，这个和git中的.gitignore一个道理，编写也比较简单，这里就不演示了。</p>`,48),z={href:"https://hub.docker.com/_/microsoft-dotnet-aspnet/%EF%BC%8C%E6%AF%8F%E4%B8%AA%E9%95%9C%E5%83%8F%E9%83%BD%E6%9C%89%E5%AF%B9%E5%BA%94%E7%9A%84Dockerfile%EF%BC%8C%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E5%B0%8F%E4%BC%99%E4%BC%B4%E5%8F%AF%E4%BB%A5%E7%82%B9%E8%BF%9B%E5%8E%BB%E7%9C%8B%E7%9C%8B%EF%BC%8C%E5%8F%82%E8%80%83%E5%8F%82%E8%80%83%E3%80%82",target:"_blank",rel:"noopener noreferrer"},G=a(`<p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142354849.webp" alt="图片" loading="lazy"></p><h1 id="_7-网络" tabindex="-1"><a class="header-anchor" href="#_7-网络" aria-hidden="true">#</a> 7 网络</h1><h2 id="_7-1-docker网络模式简介" tabindex="-1"><a class="header-anchor" href="#_7-1-docker网络模式简介" aria-hidden="true">#</a> 7.1 Docker网络模式简介</h2><p><strong>当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器默认会连接到这个虚拟网桥上</strong>。这样所有容器通过这个虚拟网桥就打通了，所以这里的docker0工作方式和物理交换机很像。</p><p>在主机上可以执行命令<code>ip link show docker0</code>查看：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142354926.webp" alt="图片" loading="lazy"></p><p><strong>Docker在启动容器时可以指定网络模式，如果不指定，默认就是采用Bridge模式</strong>；Docker的网络模式有如下几种：</p><ul><li><strong>Bridge(桥接)模式</strong>：默认的网络模式，比较适用于在同一Docker Daemon主机上运行的容器，<strong>用户也可以自定义bridge网络，优于默认的bridge网络</strong>；如果需要不同Docker主机进行通信，可以通过操作系统网络配置，也可以使用Overlay模式。</li><li><strong>Host模式</strong>：和宿主机共用一个Network Namespace。即容器不会虚拟出自己的网卡和配置自己的IP等，而是使用宿主机的IP和端口；</li><li><strong>Overlay模式</strong>：覆盖网络可以将多个 Docker Daemon主机连接在一起，并使 swarm 服务能够相互通信；也可以让Docker Daemon主机上的两个独立容器进行通信。</li><li><strong>Macvlan模式</strong>：Macvlan 网络允许为容器分配 MAC 地址，使其在网络上显示为物理设备。Docker Deamon通过容器的 MAC 地址将流量路由到容器。</li><li><strong>None模式</strong>：Docker容器拥有自己的Network Namespace，但是并不为容器进行任何网络配置。即容器没有网卡、IP、路由等信息。<strong>需要单独为Docker容器添加网卡、配置IP</strong>；</li></ul><p>Docker在启动容器的时候可以通过**--net**指定网络模式，不指定，默认就是bridge模式，如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># --net指定网络模式，这里指定为host模式
docker run -d --name testnet --net host nginx
# 通过docker inspect 容器 看网络细节，如下图
docker inspect testnet
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142354736.webp" alt="图片" loading="lazy"></p><h2 id="_7-2-bridge默认模式了解一下" tabindex="-1"><a class="header-anchor" href="#_7-2-bridge默认模式了解一下" aria-hidden="true">#</a> 7.2 Bridge默认模式了解一下</h2><p>这里就以默认的Bridge(桥接)展开来说说，其他模式后续根据应用场景再具体细说。</p><p>这里主要看看主机和容器之间的网络、容器和容器之间的网络。</p><p>在Bridge模式下，<strong>当启动容器时，Docker会分配一个IP给容器，并设置docker0的IP地址为容器的默认网关</strong>；这个时候会在主机上创建一对虚拟网卡veth pair设备接口，Docker将veth pair设备的一端配置在新启动的容器中，并命名为eth0@ifxxx（容器的网卡），另一端在主机中以veth***@ifxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中。</p><p>容器没有启动时主机的网络配置如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142354340.webp" alt="图片" loading="lazy"></p><p>当启动容器时，Docker主机就会创建一对虚拟网卡vethpair设备接口，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142354690.webp" alt="图片" loading="lazy"></p><p>可以进入到容器看看IP分配情况，如果<code>ip addr</code>命令在容器内找不到，那是因为基础镜像只包含核心命令，如果要执行其他命令，需要额外安装。可以在容器内执行如下命令进行安装。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>apt update &amp;&amp; apt install -y iproute2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>安装好之后，就可以查看容器内的IP情况了，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142354699.webp" alt="图片" loading="lazy"></p><p>这里有没有发现容器内的IP是和主机多出来的虚拟网卡是成对出现，这样主机网络和容器之间肯定能通；</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142354463.webp" alt="图片" loading="lazy"></p><p>当然容器内部也可以ping通主机。</p><p><strong>那容器之间能不能访问呢？</strong></p><p>容器内ping命令也找不到，需要进行安装，执行如下命令：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>apt update &amp;&amp; install iputils-ping
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里新启动一个容器mynginx2，IP内部分配如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142354669.webp" alt="图片" loading="lazy"></p><p><strong>mynginx容器内能ping通mynginx2，那是因为两个容器之间共用了docker0，通过docker0进行转发</strong>。</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142354413.webp" alt="图片" loading="lazy"></p><p>大概一个网络流程如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142354954.webp" alt="图片" loading="lazy"></p><p>这里的Docker0就好比是交换机，形成了网络桥梁。</p><h2 id="_7-3-如何能通过容器名进行访问" tabindex="-1"><a class="header-anchor" href="#_7-3-如何能通过容器名进行访问" aria-hidden="true">#</a> 7.3 如何能通过容器名进行访问</h2><p>默认情况，容器间的访问只能通过IP，不能通过容器名访问；</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142354220.webp" alt="图片" loading="lazy"></p><p>这种情况对于线上项目很不灵活，比如数据库备份需要临时迁移，IP可能会不一样，所以项目中的地址要重新配置，如果能通过容器名访问，那么就不用操心更换啦，只要容器名一样即可，就好比域名和IP的关系一样，IP再怎么变，域名不变就行。</p><h3 id="_7-3-1-通过-link方式" tabindex="-1"><a class="header-anchor" href="#_7-3-1-通过-link方式" aria-hidden="true">#</a> 7.3.1 通过--link方式；</h3><p>新启动一个容器mynginx3，如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># 通过--link关联 mynginx容器
docker run -d --name mynginx3 --link mynginx nginx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>容器启动之后，可以进入到容器测试：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># 进入容器
docker exec -it mynginx3 /bin/bash 
# 安装ping工具
apt update &amp;&amp; apt install iputils-ping
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142354544.webp" alt="图片" loading="lazy"></p><p>内部原理其实是在mynginx3内部做了个映射配置，容器mynginx3的hosts内容如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142354791.webp" alt="图片" loading="lazy"></p><p>这样只能在容器mynginx3内部通过mynginx容器名ping通，不能在mynginx内部通过容器名mynginx3访问，如果要达到同样的效果，就得在启动mynginx时通过--link和mynginx3关联起来。</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142354028.webp" alt="图片" loading="lazy"></p><p>如果每个容器都这样的显示指定的话，感觉就有点麻烦啦，通常的做法都是通过自定义网络方式来达到这个目的。</p><h3 id="_7-3-2-通过自定义网络方式" tabindex="-1"><a class="header-anchor" href="#_7-3-2-通过自定义网络方式" aria-hidden="true">#</a> 7.3.2 通过自定义网络方式；</h3><p>首先新创建一个网络，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142354711.webp" alt="图片" loading="lazy"></p><p>命令解析：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># --driver 指定网络模式，这里为bridge桥接模式
# --subnet 指定子网IP  192.168.0.0/16
# --gateway 指定网关 192.168.0.1
# my-net 创建的网络名
docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 my-net
# 显示网络
docker network ls
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>让启动的容器使用自定义的网络，即在启动容器时使用**--net**指定即可：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/qQ1zuvjsChSHlyAc04dcnxyu4CCzxHZddJdFOCfPlcYicJdgJ7ziacobIicqUjyW2TB9Jy7p68lbEnRn6NUMLL7pQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" loading="lazy"></p><p><strong>启动容器时不需要--link，只需要接入到自定义网络就可以通过容器名ping通了</strong>，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142354615.webp" alt="图片" loading="lazy"></p><p><strong>自定义网络之所以能通过容器名ping通，那是容器内运行了一个本地DNS解析器，该解析器将请求转发到Docker内部DNS服务器当中，DNS服务器中记录了容器启动时通过--name或--net-alias参数指定的名称与容器之间的关系</strong>。</p><p>另外还有一个点，现在分配给容器的IP是按照预先设置的子网范围进行分配的，而不是默认的docker0子网范围，执行如下命令看详细：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># 看容器详细信息
docker inspect testmynetnginx1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142354353.webp" alt="图片" loading="lazy"></p><h1 id="_8-docker-compose" tabindex="-1"><a class="header-anchor" href="#_8-docker-compose" aria-hidden="true">#</a> 8. Docker Compose</h1><p>Docker可以将应用程序及环境很方便的以容器的形式启动，但当应用程序依赖的服务比较多，或是遇到一个大系统拆分的服务很多时，如果还一个一个的根据镜像启动容器，那就有点累人了，到这有很多小伙伴会说：弄个脚本就搞定啦；要的就是这个思路，Docker提供了一个叫Docker Compose的工具，一键启动相关服务。</p><p>举个例：比如开发一个Web项目，需要有数据库、Redis、MongoDB、配置中心等等，如果将其进行容器化，可以有两种选择，第一种就是把所有的服务依赖和应用程序全部构建为一个镜像，然后以一个容器运行，即这个容器里面包含了Web应用程序、数据库、Redis、MongoDB、配置中心等；另一种方式就各自服务单独启动为一个容器服务，比较独立，一般可以一个一个的启动容器，然后通过网络连接起来就行；显然第二种方式是小伙伴们更多的选择，如果能配上一个批量操作那就完美了，而Docker Compose就是来干这个事的。</p><h2 id="_8-1-概述" tabindex="-1"><a class="header-anchor" href="#_8-1-概述" aria-hidden="true">#</a> 8.1 概述</h2><p><strong>Docker Compose 是一个用于定义和运行多个容器服务的 Docker 应用程序工具；搭配使用 YAML 文件来配置应用程序服务，然后运行Docker Compose命令，一键启动所有容器服务</strong>。</p><h2 id="_8-2-安装" tabindex="-1"><a class="header-anchor" href="#_8-2-安装" aria-hidden="true">#</a> 8.2 安装</h2>`,70),Z=e("strong",null,"Docker默认安装环境下是不包含Docker Compose工具的，需要单独安装",-1),E={href:"https://docs.docker.com/compose/install/",target:"_blank",rel:"noopener noreferrer"},C=a(`<h3 id="_8-2-1-下载文件" tabindex="-1"><a class="header-anchor" href="#_8-2-1-下载文件" aria-hidden="true">#</a> 8.2.1 下载文件</h3><p><strong>其实Docker Compose是一个可执行文件</strong>，直接下载对应文件即可，执行如下命令：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># 下载Docker Compose文件， 这个地址下载比较慢
sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose
# 这个地址快点
sudo curl -L &quot;https://get.daocloud.io/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如下图：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142354976.webp" alt="图片" loading="lazy"></p><h3 id="_8-2-2-授予执行权限" tabindex="-1"><a class="header-anchor" href="#_8-2-2-授予执行权限" aria-hidden="true">#</a> 8.2.2 授予执行权限</h3><p>下载下来的文件默认是没有执行权限的，后续需要执行，所以得授予执行权限，执行如下命令即可：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>sudo chmod +x /usr/local/bin/docker-compose
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>看看权限结果分配如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142354465.webp" alt="图片" loading="lazy"></p><p>这样docker-compose就安装完啦。</p><h3 id="_8-2-3-卸载" tabindex="-1"><a class="header-anchor" href="#_8-2-3-卸载" aria-hidden="true">#</a> 8.2.3 卸载</h3><p>如果需要卸载，直接删除即可，执行如下命令即可：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>sudo rm /usr/local/bin/docker-compose
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_8-3-使用" tabindex="-1"><a class="header-anchor" href="#_8-3-使用" aria-hidden="true">#</a> 8.3. 使用</h2><p><strong>Docker Compose需要搭配YAML文件使用，YAML 是一种人类友好的数据序列化语言，适用于所有编程语言，后缀名为.yml</strong>。</p><p>所以在进行实操前，需要大概的了解一下YAML的语法，不要慌，语法和Json的思路很像，大概了解一下，后续用到查文档就行啦。</p><h3 id="_8-3-1-简单说说语法" tabindex="-1"><a class="header-anchor" href="#_8-3-1-简单说说语法" aria-hidden="true">#</a> 8.3.1 简单说说语法</h3><p><strong>YAML文件内容是通过空格的缩进来代表层次</strong>，常用的数据类型有如下：</p><ul><li><p><strong>对象</strong>：键值对集合；</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># yaml 对象语法
testKey:testValue
# Json 语法
{&quot;testKey&quot;:&quot;testValue&quot;}
# yaml 嵌套对象
testKey:{testKey1:testValue1,testKey2:testValue2}
# Json 语法
{&quot;testKey&quot;:{&quot;testKey1&quot;:&quot;testValue1&quot;,&quot;testKey2&quot;:&quot;testValue2&quot;}}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>数组</strong>：一组按次序排列的数据；用-前缀表示。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># yaml 数组语法
-value1
-value2
-value3
# Json 数组语法
[&quot;value1&quot;,&quot;value2&quot;,&quot;value3&quot;]
# yaml 数组行内语法
testKey:[value1,value2]
# Json 语法
{&quot;testKey&quot;:[&#39;value1&#39;,&#39;value2&#39;]}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>纯量</strong>：不可再分的值，包括字符串、整数、浮点数、日期、布尔值等。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># yaml
testKey:666
# Json
{testKey:666}
# yaml
isbool:true
# Json
{isbool:true}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>常规的基本语法格式约定如下：</p><ul><li>大小写敏感</li><li>使用空格缩进表示层级关系</li><li>缩进不允许使用tab，只允许空格</li><li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li><li>&#39;#&#39;表示注释</li></ul><p>大概了解上面这些，关于日常Docker Compose用到的文件基本上够用了，如果有需要进阶的，可以去查查对应的语法。传送门：</p>`,23),I={href:"https://yaml.org/spec/1.2.2/",target:"_blank",rel:"noopener noreferrer"},O={href:"https://www.runoob.com/w3cnote/yaml-intro.html",target:"_blank",rel:"noopener noreferrer"},T=e("p",null,"关于YAML文件内容中配置的命令和Dockerfile的命令差不多是一一对应的，稍后会简单说说。",-1),P=e("h3",{id:"_8-3-2-实操撸文件",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_8-3-2-实操撸文件","aria-hidden":"true"},"#"),t(" 8.3.2 实操撸文件")],-1),M=e("p",null,"这里还是以一个WebApi为例，例中需要依赖Redis服务。",-1),L=a('<li><p><strong>创建项目，编写例子</strong></p><p>这里只是引入了一个Redis的缓存包，通过构造函数注入之后就可以直接用啦；编写了一个API接口TestCache。</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142355730.webp" alt="图片" loading="lazy"></p><p>这里还需要在Startup文件中注入相关服务，并指定Redis的连接地址，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142355845.webp" alt="图片" loading="lazy"></p><p>运行起来测试一下效果，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142355484.webp" alt="图片" loading="lazy"></p><p>Redis中也有值了，这里需要注意：存入Redis中的类型是Hash。</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142355634.webp" alt="图片" loading="lazy"></p></li>',1),B=e("p",null,[e("strong",null,"编写Dockerfile文件")],-1),V=e("p",null,"在项目根目录创建一个Dockerfile文件，内容如下：",-1),F=e("p",null,[e("img",{src:"https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142355057.webp",alt:"图片",loading:"lazy"})],-1),Y={href:"https://mp.weixin.qq.com/s?__biz=MzU1MzYwMjQ5MQ==&mid=2247485700&idx=1&sn=5b5625bde7ba831bd99946906fbd3615&chksm=fbf115d0cc869cc612e567f604ac8d1c233f739f8439df72f8bc7a194e501861efe225d44260&token=403152068&lang=zh_CN&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"},S=e("p",null,"注：这里记得将Dockerfile文件通过右键->属性->设置为始终复制，保证编译后的文件有最新文件",-1),U=e("li",null,[e("p",null,[e("strong",null,"编写Compose文件")]),e("p",null,"在项目根目录下创建docker-compose.yml文件，内容如下："),e("p",null,[e("img",{src:"https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142355217.webp",alt:"图片",loading:"lazy"})]),e("p",null,"有了这个项目就可以一键启动了，这里需要稍微改一下我们原来的代码，如下："),e("p",null,[e("img",{src:"https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142355078.webp",alt:"图片",loading:"lazy"})]),e("p",null,"注：这里记得将docker-compose.yml文件通过右键->属性->设置为始终复制，保证编译后的文件有最新文件。")],-1),H=a(`<h3 id="_8-3-3-体验一键启动" tabindex="-1"><a class="header-anchor" href="#_8-3-3-体验一键启动" aria-hidden="true">#</a> 8.3.3 体验一键启动</h3><ul><li><p><strong>将项目先发布</strong>，并拷贝到对应的服务器上，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142355096.webp" alt="图片" loading="lazy"></p><p>这里用的是我的阿里云服务器，拷贝文件如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142355902.webp" alt="图片" loading="lazy"></p></li><li><p><strong>一键启动</strong></p><p>在docker-compose.yml所在的目录下执行如下命令：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker-compose up
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>下面是执行docker-compose up内部执行的步骤：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142355595.webp" alt="图片" loading="lazy"></p><p>先是构建我们的程序，然后拉取依赖的Redis服务，并启动，最后启动我们的程序。(执行顺序和依赖有关系)；启动之后就可以根据docker-compose.yml文件中映射的端口访问了，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142355875.webp" alt="图片" loading="lazy"></p></li><li><p><strong>看看启动的容器名</strong></p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142355511.webp" alt="图片" loading="lazy">image-20211007165313310</p><p>通过<code>docker ps -n 2</code> 查看最近启动的容器，容器的名字规则是：<strong><code>目录名_Compose文件中定义的服务名_序号</code></strong>，那小伙伴肯定会好奇为什么程序能通过myredis名字连接到redis，可以通过<code>docker inspect composetest_myredis_1</code>查看容器详情：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142356579.webp" alt="图片" loading="lazy"></p><p>同样可以查看到API服务对应的容器也是用的composetest_default这个网络，这个网络是一个桥接模式，可以通过<code>docker network ls</code>看到，如下：</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142356141.webp" alt="图片" loading="lazy"></p></li><li><p><strong>docker compose常用命令</strong></p><p><code>docker-compose build</code>:构建或者重新构建服务</p><p><code>docker-compose up</code>:构建、启动容器，加上-d选项代表后台运行。</p><p><code>docker-compose ps</code>：列出所有通过Compose运行的容器</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142356611.webp" alt="图片" loading="lazy"></p><p><code>docker-compose logs</code>：打印相关日志信息</p><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/202111142356935.webp" alt="图片" loading="lazy"></p><p><code>docker-compose stop/start/restart</code>d：可以指定服务停止、开始和重新启动</p><p>docker-compose命令和docker的命令基本是一样的。</p></li><li><p><strong>docker-compose.yml文件内容常用属性</strong></p><p><strong>version</strong>：指定 docker-compose.yml 文件的版本，一般都是用version 3；</p><p><strong>services</strong>：定义多个容器集合，有多少写多少；</p><p><strong>build</strong>：构建镜像，和<code>docker build</code>一样功效；</p><p><strong>environment</strong>：配置环境变量，和Dockerfile中ENV 关键字功能一样；</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># 设置环境变量
environment:
  RACK_ENV: development
  SHOW: &#39;true&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>expose</strong>：暴露端口，和Dockerfile中的EXPOSE 关键字功能一样；</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>expose:
  - &quot;80&quot;
  - &quot;9999&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>ports</strong>：配置端口映射，和<code>docker run -p</code>一样功效</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ports:
 - &quot;8080:80&quot;
 - &quot;6379:6379&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>volumes</strong>：指定卷挂载路径，与Dockerifle中的VOLUME 关键字功能一样</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>volumes:
  - /var/lib/mysql
  - /opt/data:/var/lib/mysql
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>command</strong>：覆盖容器启动后默认执行的命令，和Dockerfile文件中的CMD命令一样；</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>command: bundle exec thin -p 3000
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>image</strong>：指定要用的镜像，构建的时候会拉取。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># 指定要使用redis镜像
image: redis
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul>`,2),K={href:"https://docs.docker.com/compose/compose-file/compose-file-v3/",target:"_blank",rel:"noopener noreferrer"},W={href:"https://gitee.com/CodeZoe/microservies-demo/tree/main/DockerComposeDemo",target:"_blank",rel:"noopener noreferrer"},$=e("h1",{id:"资料",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#资料","aria-hidden":"true"},"#"),t(" 资料")],-1),J=e("p",null,"来自微信公众号【Code综艺圈】",-1);function Q(X,j){const r=d("ExternalLinkIcon");return o(),n("div",null,[c,e("blockquote",null,[e("p",null,[t("Docker在线版："),e("a",p,[t("https://labs.play-with-docker.com/"),s(r)])]),e("p",null,[t("书籍推荐："),e("a",g,[t("https://www.cnblogs.com/Can-daydayup/p/15585714.html"),s(r)])])]),m,e("p",null,[t("以上只是总结了平时比较常用的命令，并没有全部列出，更多细节可以进入官网："),e("a",u,[t("https://docs.docker.com/engine/reference/commandline/rm/；"),s(r)])]),b,h,v,k,e("ul",null,[e("li",null,[x,w,_,e("p",null,[t("命令简述："),f,t("，直接根据镜像centos以交互模式启动容器，容器名称为mycentos，在容器内部执行/bin/bash命令进入到终端；具体命令在"),e("a",y,[t("Docker小白到实战之常用命令演示，通俗易懂"),s(r)]),t("这篇文章中已经详细说明；这里简单回顾一下根据镜像启动容器流程，如图：")]),D]),R]),N,e("p",null,[t("以下关于项目创建和发布的具体细节在第一篇最后就分享了，小伙伴可以"),e("a",A,[t("参考"),s(r)]),t("，这里主要演示Dockerfile关键字。")]),q,e("p",null,[t("对了，.NetCore的镜像列表可以参照这个地址："),e("a",z,[t("https://hub.docker.com/_/microsoft-dotnet-aspnet/，每个镜像都有对应的Dockerfile，感兴趣的小伙伴可以点进去看看，参考参考。"),s(r)])]),G,e("p",null,[Z,t("。Docker Compose工具搭配Docker才有意义，所以安装Docker Compose之前需要安装Docker。以下演示平台为Linux，其他平台请参照文档："),e("a",E,[t("https://docs.docker.com/compose/install/"),s(r)])]),C,e("p",null,[e("a",I,[t("https://yaml.org/spec/1.2.2/"),s(r)])]),e("p",null,[e("a",O,[t("https://www.runoob.com/w3cnote/yaml-intro.html"),s(r)])]),T,P,M,e("ul",null,[L,e("li",null,[B,V,F,e("p",null,[t("关于Dockerfile中的内容这里就不细说了，之前有一篇文章专门分享的(点"),e("a",Y,[t("这里"),s(r)]),t(")。这里的Dockerfile目的就是将我们的WebApi项目构建为镜像，和Redis没有关系，不过这里不是通过执行命令构建，而是通过Compose文件一起构建。")]),S]),U]),H,e("p",null,[t("上面列出了一些比较常用的，具体的可以参考官网："),e("a",K,[t("https://docs.docker.com/compose/compose-file/compose-file-v3/"),s(r)])]),e("p",null,[t("代码地址如下："),e("a",W,[t("https://gitee.com/CodeZoe/microservies-demo/tree/main/DockerComposeDemo"),s(r)])]),$,J])}const te=i(l,[["render",Q],["__file","base.html.vue"]]);export{te as default};
