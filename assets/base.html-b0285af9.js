import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o,c as n,a as e,b as a,d as c,e as l}from"./app-77ed49ef.js";const s={},p=l('<h1 id="实时通信技术大乱斗" tabindex="-1"><a class="header-anchor" href="#实时通信技术大乱斗" aria-hidden="true">#</a> 实时通信技术大乱斗</h1><p>现代应用程序的很多功能依赖于实时通信技术：</p><ul><li>聊天</li><li>实时股票更新</li><li>现场拍卖</li><li>体育/新闻实时更新</li><li>多人游戏</li><li>位置服务</li><li>进度条</li></ul><p>HTTP通信的核心一直没变，依旧是<strong>请求/响应模型</strong>，这给实时通信带来了根本性挑战。</p><p>多年来，开发者一直在尝试以各种姿势规避HTTP障碍。<br> 我们快速总结流行的几种技术，每种技术都有一个真实的轶事，以便于解释。</p><h2 id="定期轮询" tabindex="-1"><a class="header-anchor" href="#定期轮询" aria-hidden="true">#</a> 定期轮询</h2><blockquote><p>带小孩徒步旅行？<br> 孩子们间隔1,2分钟就问：“我们到了吗？”，你的回答干脆友善，但询问/应答会持续出现。</p></blockquote><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/regularpoll.png" alt="img" loading="lazy"><br> 客户端定期询问服务器是否有新信息， 显然这不是实时的，如果轮询间隔足够短，可能会有一点效果。</p><p>定期轮询确实会导致客户端-服务器之间反复不必要的往返。</p><h2 id="长轮询" tabindex="-1"><a class="header-anchor" href="#长轮询" aria-hidden="true">#</a> 长轮询</h2><blockquote><p>与你的孩子开启另一趟徒步旅程。<br> 但这一次，当孩子询问， “我们到了吗？”，你只是保持沉默，一直到下一站（或者发脾气）才做出回应。</p></blockquote><figure><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/longpoll.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>长轮询是轮询的一种高级形式，可满足实时通信的需要。</p><p>客户端向服务器发出信息请求，服务器hold请求，直到发生值得关注的事情（或请求即将超时）。</p><p>于此同时，客户端需要针对响应和超时进行编程，以立即发起另一个请求。这样确保客户端/服务器具有持续的Comet请求以接受实时响应。</p><p>长轮询和轮询比起来，明显减少了很多不必要的http请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</p><p>长轮询仍然很流行，但它通常需要在服务器和客户端自定义编程才能成功实现。</p><h2 id="服务端发送事件-sse" tabindex="-1"><a class="header-anchor" href="#服务端发送事件-sse" aria-hidden="true">#</a> 服务端发送事件 (SSE)</h2><blockquote><p>你在电商上购物，勾选了推送复选框。<br> 之后你每天都会收到三次营销邮件。</p></blockquote><figure><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/sse257b450a591144e28ff3fbe36892dd2f.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>SSE是HTML5 新增的功能，SSE最大的特点就是不需要客户端发送请求，可以实现只要服务器端数据有更新，就可以马上发送到客户端。</p><p>SSE很大程度上是从服务器到客户端的定向推送，客户端使用EventSource对象（HTML5标准）捕获来自服务器的流式通知。</p><h2 id="websockets" tabindex="-1"><a class="header-anchor" href="#websockets" aria-hidden="true">#</a> WebSockets</h2><blockquote><p>你首次去国外旅行，一旦与对方确认了语言，后续沟通就无障碍。</p></blockquote><p><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/websocketsbad3e7cd28fd4b4c9b45a3d0617cb2d8.png" alt="img" loading="lazy"><br> WebSockets依赖于http1.1的持久连接机制，WebSockets握手阶段需要http，连接一旦建立，客户端和服务器端就处于平等的地位，可以全双工通信，不存在请求和响应的区别。</p><p>以上技术可以解决HTTP障碍并促进实时通信。问题在于，大多数这些技术都需要开发人员的大量工作。<br> 如果有一些框架可以消除通信的复杂性，让开发人员可以专注于构建实时应用程序，那岂不是很好吗？</p><h3 id="signalr是-net技术栈成熟的实时通信框架。" tabindex="-1"><a class="header-anchor" href="#signalr是-net技术栈成熟的实时通信框架。" aria-hidden="true">#</a> SignalR是.NET技术栈成熟的实时通信框架。</h3><p>SignalR为服务器和客户端之间的双向远程过程调用（RPC）提供API，消除了实时通信的复杂性。</p><blockquote><p>SignalR提供了统一的API画布用于连接和客户端管理，以及进行扩展以处理增加的流量。<br> SignalR使用服务器端集线器的概念来帮助已连接客户端的实时通信和管理。服务器和客户端可以无缝地相互调用方法，这种交互方法是强类型的。<br> 虽然默认使用基于文本的JSON格式，但SignalR还支持Messagepack协议-(二进制数据序列化/反序列化)，以提高效率。</p></blockquote><p>signalr是微软推出的标准框架， 目前我已知有node，golang的实现。</p><h2 id="grpc" tabindex="-1"><a class="header-anchor" href="#grpc" aria-hidden="true">#</a> gRPC</h2><blockquote><p>2015年推出的基于HTTP/2，专注于安全、数据压缩、更好的性能和更低的延迟。</p></blockquote><figure><img src="https://gitee.com/AZRNG/picture-storage/raw/master/kbms/21.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>gRPC是由Google开发的基于HTTP/2协议实现的高性能通用RPC框架。<strong>HTTP/2 的多路复用特性</strong>支撑了gRPC的流式传输能力。</p><p>开箱即用的gRPC提供了丰富的功能，例如集成身份验证，双向流和流控制。</p><blockquote><p>gRPC自动为各种语言和平台生成跨平台客户端和服务器绑定代码。gRPC服务的定义和信息交换的格式是Protocol Buffers（一种功能强大的二进制序列化/反序列化工具集和语言）。</p></blockquote><h1 id="资料" tabindex="-1"><a class="header-anchor" href="#资料" aria-hidden="true">#</a> 资料</h1>',37),g={href:"https://www.cnblogs.com/JulianHuang/p/15379648.html",target:"_blank",rel:"noopener noreferrer"};function d(h,b){const t=i("ExternalLinkIcon");return o(),n("div",null,[p,e("p",null,[a("来源：博客猿马甲哥 "),e("a",g,[a("https://www.cnblogs.com/JulianHuang/p/15379648.html"),c(t)])])])}const f=r(s,[["render",d],["__file","base.html.vue"]]);export{f as default};
