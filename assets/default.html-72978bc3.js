const e=JSON.parse('{"key":"v-28cb1d02","path":"/dotnetcore/DI/default.html","title":"默认依赖注入","lang":"zh-CN","frontmatter":{"title":"默认依赖注入","lang":"zh-CN","date":"2021-08-25T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["dotNet"],"tag":["cache","di"],"description":"介绍 不应该依赖于具体的实现，应该依赖于抽象，高层模块不应该依赖于底层模块，二者应该依赖于抽象(否则业务变更，改动比较大)。简单的说就是为了更好的解耦。而控制反转(Ioc)就是这样的原则的其中一个实现思路, 这个思路的其中一种实现方式就是依赖注入(DI)。(官方原话：依赖注入(DI)这是一种在类和依赖项之间实现控制反转(Ioc)的技术)， dotNet内置有对依赖注入(DI)的支持，提供了一个内置的服务容器IServiceProvider，程序在启动时候我们预先将服务注册不同生命周期到ServiceCollection，然后利用ServiceCollection来创建ServiceProvider，利用后者提供服务实例，将服务注入到使用到它的类的构造函数中。","head":[["meta",{"property":"og:url","content":"https://kbms.vercel.app/dotnetcore/DI/default.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"默认依赖注入"}],["meta",{"property":"og:description","content":"介绍 不应该依赖于具体的实现，应该依赖于抽象，高层模块不应该依赖于底层模块，二者应该依赖于抽象(否则业务变更，改动比较大)。简单的说就是为了更好的解耦。而控制反转(Ioc)就是这样的原则的其中一个实现思路, 这个思路的其中一种实现方式就是依赖注入(DI)。(官方原话：依赖注入(DI)这是一种在类和依赖项之间实现控制反转(Ioc)的技术)， dotNet内置有对依赖注入(DI)的支持，提供了一个内置的服务容器IServiceProvider，程序在启动时候我们预先将服务注册不同生命周期到ServiceCollection，然后利用ServiceCollection来创建ServiceProvider，利用后者提供服务实例，将服务注入到使用到它的类的构造函数中。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2022-12-09T02:19:17.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"cache"}],["meta",{"property":"article:tag","content":"di"}],["meta",{"property":"article:published_time","content":"2021-08-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2022-12-09T02:19:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"默认依赖注入\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-08-25T00:00:00.000Z\\",\\"dateModified\\":\\"2022-12-09T02:19:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"Singleton(单例)","slug":"singleton-单例","link":"#singleton-单例","children":[]},{"level":2,"title":"Scoped(作用域)","slug":"scoped-作用域","link":"#scoped-作用域","children":[]},{"level":2,"title":"Transient(瞬时)","slug":"transient-瞬时","link":"#transient-瞬时","children":[]},{"level":2,"title":"构造函数注入","slug":"构造函数注入","link":"#构造函数注入","children":[]},{"level":2,"title":"FromServices注入","slug":"fromservices注入","link":"#fromservices注入","children":[]},{"level":2,"title":"构造函数获取服务","slug":"构造函数获取服务","link":"#构造函数获取服务","children":[]},{"level":2,"title":"IServiceProvider获取","slug":"iserviceprovider获取","link":"#iserviceprovider获取","children":[]},{"level":2,"title":"ConfigureServices中获取服务","slug":"configureservices中获取服务","link":"#configureservices中获取服务","children":[]},{"level":2,"title":"Configure中获取服务","slug":"configure中获取服务","link":"#configure中获取服务","children":[]},{"level":2,"title":"构建子容器","slug":"构建子容器","link":"#构建子容器","children":[]},{"level":2,"title":"异步获取","slug":"异步获取","link":"#异步获取","children":[]}],"git":{"createdTime":1670219403000,"updatedTime":1670552357000,"contributors":[{"name":"zhangyunpeng","email":"zhang.yunpeng@synyi.com","commits":2},{"name":"azrng","email":"itzhangyunpeng@163.com","commits":1}]},"readingTime":{"minutes":3.99,"words":1196},"filePathRelative":"dotnetcore/DI/default.md","localizedDate":"2021年8月25日","excerpt":"<h1> 介绍</h1>\\n<p>不应该依赖于具体的实现，应该依赖于抽象，高层模块不应该依赖于底层模块，二者应该依赖于抽象(否则业务变更，改动比较大)。简单的说就是为了更好的解耦。而控制反转(Ioc)就是这样的原则的其中一个实现思路, 这个思路的其中一种实现方式就是依赖注入(DI)。(官方原话：依赖注入(DI)这是一种在类和依赖项之间实现控制反转(Ioc)的技术)，</p>\\n<p>dotNet内置有对依赖注入(DI)的支持，提供了一个内置的服务容器IServiceProvider，程序在启动时候我们预先将服务注册不同生命周期到ServiceCollection，然后利用ServiceCollection来创建ServiceProvider，利用后者提供服务实例，将服务注入到使用到它的类的构造函数中。</p>","autoDesc":true}');export{e as data};
