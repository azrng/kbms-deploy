import{_ as i,W as n,X as o,Y as e,Z as t,$ as r,a0 as a,C as h}from"./framework-63781bb7.js";const s={},g=a('<h1 id="说明" tabindex="-1"><a class="header-anchor" href="#说明" aria-hidden="true">#</a> 说明</h1><p>集中式的版本控制：版本库是集中存放在中央服务器的，需要首先去中央服务器取得最新的版本，然后每次编辑完以后在推送到中央服务器，最大的缺点就是必须联网才可以使用，如果是局域网的话宽带大，如果是在互联网上，网速慢的情况，提交非常慢。</p><p>分布式版本控制：没有中央服务器，每一个人的电脑上都是一个完整的版本库，推送的时候是两个人吧各自的修改推送给对方，然后就可以看到对方的修改。分布式安全性更高，因为每个人的电脑里面都存在完整的版本库。但是实际上，分布式版本控制也有一个电脑充当与中央服务器，它是用来方便“交换”大家的修改。</p><h1 id="常用操作" tabindex="-1"><a class="header-anchor" href="#常用操作" aria-hidden="true">#</a> 常用操作</h1><p>1、如果你提交时候发现对方已经提交到远程，那么你提交时候回报错提示对方已经提交有东西。</p><p>解决方法：</p><p>a、b两人拉取主分支（保持主分支是最新的），然后分别在主分支上面创建分支a1、b1,然后切换到</p><p>各自的分支，a修改了一些数据，然后提交推送到了分支a1，b在分支b1上面修改并提交推送了一些东西到分支b1，然后a切换到主分支，右键合并分支，从a1分支合并，合并过以后切记要进行推送，b也切换到主分支，先拉取一下主分支（拉取成最新的数据），然后右键合并分支从b1合并分支并提交推送。</p><p>如果a接着开发，那么a需要在主分支拉取下最新数据，然后切换到分支a1，然后点击右键合并从主分支，这样子把分支a1也弄成了最新数据。b操作了也先拉取。</p><p>目前可以正常操作的拉取方式：如果有修改，那么先提交，然后拉取，这个时候可能出错，那么不要担心，正常解决冲突就行，然后拉取成功后，查看下项目有没有问题，没有问题的话就可以推送上去。</p><p>同步：从远程存储库往本地同步（拉取代码）</p><p>拉取：从远程拉取最新版本到本地自动合并</p><p>获取：从远程获取最新版本到本地，不会自动合并，实际使用中这种更安全（获取后还需要从远程这个分支合并到本地这个分支）</p><p>推送：推送到远程服务存储库</p><p>提交：相当于commit，提交到本地存储库</p><p>提交和推送：现在本地存储库提交然后再推送到远程服务器</p><p>提交和同步：先提交到本地然后拉取远程服务器然后再推送</p><h1 id="vs团队资源管理器" tabindex="-1"><a class="header-anchor" href="#vs团队资源管理器" aria-hidden="true">#</a> VS团队资源管理器</h1><figure><img src="https://cdn.jsdelivr.net/gh/azrng/file/blog202212132233248.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>常见名词解释：</p><p>拉取（Pull）：将远程版本库合并到本地版本库，相当于（Fetch+Meger）</p><p>获取（Fetch）：从远程版本库获得最新版本</p><p>合并（Meger）：将两个版本库进行合并操作</p><p>提交（Commit）：将所做的更改，存入本地暂存库</p><p>推送（Push）：将所做的更改，存入远程版本库</p><p>同步（Pull+Push）：先将远程库拉取，再将本地库推送到远程库，相当于（Pull+Push）</p><p>变基到（Switch）：切换分支（双击即可切换）</p><p>常用功能简单说明</p><figure><img src="https://cdn.jsdelivr.net/gh/azrng/file/blog202212132233191.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>【更改】</p><p>负责文件的修改、添加、忽略文件、删除文件提交到本地服务器，主要是：提交</p><p>【分支】</p><p>​ 负责合并分支，切换分支，主要是合并、变基到、解决冲突</p><p>【同步】</p><p>​ 远程Git存储库与本地Git存储库操作，主要是：推送、同步、拉取、获取</p><p>【设置】</p><p>设置用户名、密码、远程地址、对比工具等</p>',37),l={href:"https://www.cnblogs.com/mqxs/p/9497096.html",target:"_blank",rel:"noopener noreferrer"},c=a('<h1 id="忽略文件规则" tabindex="-1"><a class="header-anchor" href="#忽略文件规则" aria-hidden="true">#</a> 忽略文件规则</h1><p>创建git项目，创建的时候有个.gitignore的选项，根据自己的需要选择需要忽视的文件，例如：java，python等，C#的项目选择VisualStudio，因为创建的都是VS项目，这里面有需要C#项目所忽略的设置。创建完项目之后，项目下面就有个.gitignore文件，这个文件是可以修改的。</p><h2 id="忽略文件" tabindex="-1"><a class="header-anchor" href="#忽略文件" aria-hidden="true">#</a> 忽略文件</h2><p>例如：忽视后缀是.suo，.user的文件，*正式所有 *.suo *.user</p><p>\\1. 编译生成的文件，例如：dll，等</p><p>\\2. 配置文件，敏感的信息（密码，口令）</p><p>\\3. 项目工具生成的文件，例如：引用Nuget时生成的packages等</p><p>\\4. 项目测试的文件，日志文件等。</p><p><strong>.gitignore****忽略规则的匹配语法</strong></p><p>\\1. “#&quot;开头，是git上的注释说明</p><p>\\2. 以&quot;/&quot;开头表示根目录，其他位置的“/”表示的是忽视目录</p><p>3.“*”匹配多个字符，“**”匹配任意中间目录</p><p>4.“[]”匹配中括号中的字符</p><p>5.“!”表示不忽视,即：如果忽视某些文件，可以用!让这些文件在启用，如果文件夹的父目录被忽略了，那么这个文件在启用，也就没有什么用了。</p><p>注意：git对于.ignore配置文件是从上到下进行规则匹配的，如果前面的规则匹配的范围更大，则后面的规则将不会生效；git上的忽视文件.ignore要在创建git的时候创建，如果是之后创建的，已经push过的，在忽视将不起作用，因为git已经开始管理这些文件了。</p><p><strong>.gitignore****查看忽视文件和文件夹</strong></p><p>git check-ignore -v bin</p><p>.gitignore:23:[Bb]in/ bin</p><p>查看忽视文件夹，可以看到，第23行的忽视规则把bin给忽视掉了，如果运行指令，没有返回值则表示没有忽视此文件或者文件夹的规则。</p><p><strong>git****忽视已经上传的文件解决办法</strong></p><p>在使用git的时候，创建了一个.gitignore文件，但是后来发现有一个文件已经上传了，没有写忽视规则，但是又想这个文件【本地保存】，【远程删除】，例如：忽视已经上传的文件【test.txt】或者文件夹，用git rm -r –cached directory</p><ul><li>git rm -r --cached test.txt</li><li>commit和push</li></ul><p>操作之后，你可以看到本地文件还在，远程的已经删除了</p><h2 id="忽略文件夹" tabindex="-1"><a class="header-anchor" href="#忽略文件夹" aria-hidden="true">#</a> 忽略文件夹</h2><p>[Dd]用的是正则，匹配大小写d，两个**表示匹配任意中间目录</p><p>[Dd]ebug/</p><p>[Dd]ebugPublic/</p><p>[Rr]elease/</p><p>[Rr]eleases/</p><h2 id="中途修改忽略文件" tabindex="-1"><a class="header-anchor" href="#中途修改忽略文件" aria-hidden="true">#</a> 中途修改忽略文件</h2><p>需要清空git缓存，项目目录中右键bash</p><p>git rm -r --cached .</p><p>git add .</p><p>git commit -m &#39;update .gitignore&#39;</p><h1 id="资料" tabindex="-1"><a class="header-anchor" href="#资料" aria-hidden="true">#</a> 资料</h1>',35),d={href:"https://www.liaoxuefeng.com/wiki/896043488029600",target:"_blank",rel:"noopener noreferrer"},u={href:"https://www.cnblogs.com/wupeixuan/p/11947343.html",target:"_blank",rel:"noopener noreferrer"},b={href:"https://www.cnblogs.com/huangtailang/p/4748075.html",target:"_blank",rel:"noopener noreferrer"},m={href:"https://learngitbranching.js.org/",target:"_blank",rel:"noopener noreferrer"},f={href:"https://github.com/k88hudson/git-flight-rules/blob/master/README_zh-CN.md",target:"_blank",rel:"noopener noreferrer"};function _(w,x){const p=h("ExternalLinkIcon");return n(),o("div",null,[g,e("p",null,[t("文档地址："),e("a",l,[t("https://www.cnblogs.com/mqxs/p/9497096.html"),r(p)])]),c,e("p",null,[t("廖雪峰Git教程："),e("a",d,[t("https://www.liaoxuefeng.com/wiki/896043488029600"),r(p)])]),e("p",null,[e("a",u,[t("https://www.cnblogs.com/wupeixuan/p/11947343.html"),r(p)])]),e("p",null,[e("a",b,[t("https://www.cnblogs.com/huangtailang/p/4748075.html"),r(p)]),t(" | Git 以分支的方式同时管理多个项目 - HTL - 博客园")]),e("p",null,[t("线上学习："),e("a",m,[t("https://learngitbranching.js.org/"),r(p)])]),e("p",null,[t("Git飞行指南："),e("a",f,[t("https://github.com/k88hudson/git-flight-rules/blob/master/README_zh-CN.md"),r(p)])])])}const v=i(s,[["render",_],["__file","overview.html.vue"]]);export{v as default};
