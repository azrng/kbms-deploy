import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,d as r,o as i}from"./app-fQkBsvt-.js";const a="/kbms/common/1609838929172-9922ab7a-6416-4f10-8a28-f704b4f495f4.png",t={};function o(l,e){return i(),n("div",null,e[0]||(e[0]=[r('<p><a href="http://xn--2rqz13g.NET" target="_blank" rel="noopener noreferrer">使用.NET</a> Core创建Windows服务<br> 使用微软推荐方式<br> 使用Topshelf方式<br>  <br>  <br><strong>安装步骤</strong><br><a href="http://xn--ykqpua31cv0dd80an4dw50e98lviy50bz27am4fvr4a.NET" target="_blank" rel="noopener noreferrer">这里首先你要确保你已经安装了.NET</a> Core 3.0或以上版本。在我编写这篇文章的时候， .NET Core 3.1刚刚发布，Visual Studio应该会提示你升级到最新版本。<a href="http://xn--gqq5bs54a0qcguow0hbrcnv3i.NET" target="_blank" rel="noopener noreferrer">但是如果你想要在.NET</a> Core 2.x项目中使用这个方式，应该是行不通的。<br> 如果你喜欢使用命令行创建项目，你就需要使用工作器(worker)类型创建项目：<br> dotnet new worker<br> 如果你是一个和我一样喜欢使用Visual Studio的开发人员，那么你可以在Visual Studio中使用项目模板完成相同的功能。<br><img src="'+a+`" alt="image.png" loading="lazy"><br> 这样做将创建出一个包含两个文件的项目。其中Program.cs文件是应用的启动“引导程序”。另外一个文件是worker.cs文件，在这个文件中，你可以编写你的服务逻辑。<br> 这看起来应该是相当的容易，但是为这个程序添加额外的并行后台服务，你还需要添加一个类，并让它继承BackgroundService类:</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyNewBackgroundWorker</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> : </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">BackgroundService</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">protected</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> override</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Task</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ExecuteAsync</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">CancellationToken</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> stoppingToken</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)   </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//Do something.</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在Program.cs中，我们要做的只是把当前的Worker注册到服务集合(Service Collection)中即可。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>.ConfigureServices((hostContext, services) =&gt;</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>services.AddHostedService&lt;Worker&gt;();</span></span>
<span class="line"><span>services.AddHostedService&lt;MyNewBackgroundWorker&gt;();</span></span>
<span class="line"><span>});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际上作为“后台服务”任务的运行程序，AddHostedService方法已经在框架中存在了很长时间了。<a href="http://xn--ASP-p18dknnn0vz5n85bd9umxlr4gs1oka3469e2ur1yl.NET" target="_blank" rel="noopener noreferrer">在之前我们已经完成的一篇关于ASP.NET</a> Core托管服务的文章， 但是在当时场景中，我们托管是是整个应用，而非一个在你应用程序幕后运行的东西。<br><strong>运行/调试我们的应用</strong><br> 在默认的工作器(worker)模板中，已经包含了一个后台服务，这个服务可以将当前时间输出到控制台窗口。下面让我们点击F5来运行程序，看看我们能得到什么。<br> info: CoreWorkerService.Worker[0]<br> Worker running at: 12/07/2019 08:20:30+13:00<br> info: Microsoft.Hosting.Lifetime[0]<br> Application started. Press Ctrl+C to shut down.<br> 在我们启动程序之后，程序立刻就运行了！我们可以保持控制台的打开状态来调试应用，或者直接关闭窗口退出。相较于使用&quot;Microsoft&quot;方式来调试一个Windows服务，这简直就是天堂。<br> 这里我们需要注意的另外一件事情是编写控制台程序的平台。在最后，我们不仅在控制台窗口输出了时间，还通过依赖注入创建了一个托管worker. 我们也可以使用依赖注入容器来注入仓储，配置环境变量，获取配置等。<br><strong>但这里我们还没有做的事情是，将这个应用转换为Windows服务</strong>。。<br><strong>将我们的应用转换成Window服务</strong><br> 为了将应用转换成Windows服务，我们需要使用如下命令引入一个包。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Install-Package Microsoft.Extensions.Hosting.WindowsServices</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>下一步，我们需要修改Program.cs文件，添加UseWindowsService()方法的调用。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public static IHostBuilder CreateHostBuilder(string[] args) =&gt;</span></span>
<span class="line"><span>Host.CreateDefaultBuilder(args)</span></span>
<span class="line"><span>.ConfigureServices((hostContext, services) =&gt;</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>services.AddHostedService&lt;Worker&gt;();</span></span>
<span class="line"><span>})</span></span>
<span class="line"><span>.UseWindowsService();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上就是所有需要变更的代码。<br> 运行我们的程序，你会发现和之前的效果完全样。但是这里最大的区别是，我们可以将当前应用以Windows服务的形式安装了。<br> 为了实现这一目的，我们需要发布当前项目。在当前项目目录中，我们可以运行以下命令：<br> dotnet publish -r win-x64 -c Release<br> 然后我们就可以借助标准的Windows服务安装器来安装当前服务了。<br> sc create TestService BinPath=C:\\full\\path\\to\\publish\\dir\\WindowsServiceExample.exe<br> 当前，你也可以使用Windows服务安装器的其他命令。<br> sc start TestServicesc stop TestServicesc delete TestService<br> 最后检查一下我们的服务面板。<br> 服务已经正常工作了。<br><strong>在Linux中运行服务</strong><br> 老实说，我没有太多的Linux经验，但是终归是需要了解一下...<br> 在Linux系统中, 如果你希望我们编写的“Windows”服务在Linux系统中作为服务运行，你需要做以下2步：<br> 使用Microsoft.Extensions.Hosting.Systemd替换之前的Microsoft.Extensions.Hosting.WindowsServices。<br> 使用UseSystemd()替换UseWindowsService()。<br><strong>Microsoft vs Topshelf vs .NET Core Workers</strong><br> 到现在为止，我们已经介绍了借助3种不同的方式来创建Windows服务。<br><strong>你可能会问“好吧，那我到底应该选择哪一种？”</strong><br> 这里呢，我们可以首先把&quot;Microsoft&quot;这种老派学院式的方式抛弃。因为它的调试实在是太麻烦了，而且没有什么实际的用处。<br><a href="http://xn--Topshelf-t39lt47akqerubwy8ch55azt8a5zr.NET" target="_blank" rel="noopener noreferrer">然后剩下的就是Topshelf和.NET</a> Core工作器两种方式了。在我看来，.NET Core工作器，<a href="http://xn--y5q10r1wdoybv48c4nky1o.NET" target="_blank" rel="noopener noreferrer">已经很好的融入.NET</a> Core生态系统，<a href="http://xn--ASP-x69d36rtvfmyepwnxptlui.NET" target="_blank" rel="noopener noreferrer">如果你正在开发ASP.NET</a> Core应用，<a href="http://xn--6iq82an04f67w.NET" target="_blank" rel="noopener noreferrer">那么使用.NET</a> Core工作器就很有意义。最重要的是，当你创建一个后台服务的时候，<a href="http://xn--ASP-p18dohn5buy00ygqhtvl4q7k.NET" target="_blank" rel="noopener noreferrer">你可以让它在一个ASP.NET</a> Core网站中的任意位置运行，这非常的方便。但是缺点是安装。你必须使用SC命令来安装服务。这一部分Topshelf可能更胜一筹。<br> Topshelf总体上将非常的友好，并且具有最好的安装方式，但是使用额外的库，也增加了学习的成本。<br><a href="http://xn--Topshelf-vp1m608biw0b.NET" target="_blank" rel="noopener noreferrer">所以Topshelf和.NET</a> Core工作器，大家可以自行选择，都是不错的方案。</p>`,9)]))}const c=s(t,[["render",o],["__file","netcorechuangjianwindowsfuwu.html.vue"]]),h=JSON.parse('{"path":"/dotnet/csharp/windowfuwu/netcorechuangjianwindowsfuwu.html","title":"netcore创建windows服务","lang":"zh-CN","frontmatter":{"title":"netcore创建windows服务","lang":"zh-CN","date":"2023-10-22T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["csharp"],"tag":["无"],"filename":"netcorechuangjianwindowsfuwu","slug":"kwsz8q","docsId":"29635041","description":"使用.NET Core创建Windows服务 使用微软推荐方式 使用Topshelf方式 安装步骤 这里首先你要确保你已经安装了.NET Core 3.0或以上版本。在我编写这篇文章的时候， .NET Core 3.1刚刚发布，Visual Studio应该会提示你升级到最新版本。但是如果你想要在.NET Core 2.x项目中使用这个方式，应该是行不...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dotnet/csharp/windowfuwu/netcorechuangjianwindowsfuwu.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"netcore创建windows服务"}],["meta",{"property":"og:description","content":"使用.NET Core创建Windows服务 使用微软推荐方式 使用Topshelf方式 安装步骤 这里首先你要确保你已经安装了.NET Core 3.0或以上版本。在我编写这篇文章的时候， .NET Core 3.1刚刚发布，Visual Studio应该会提示你升级到最新版本。但是如果你想要在.NET Core 2.x项目中使用这个方式，应该是行不..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://azrng.gitee.io/kbms/kbms/common/1609838929172-9922ab7a-6416-4f10-8a28-f704b4f495f4.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-11-17T15:44:14.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-10-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-11-17T15:44:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"netcore创建windows服务\\",\\"image\\":[\\"https://azrng.gitee.io/kbms/kbms/common/1609838929172-9922ab7a-6416-4f10-8a28-f704b4f495f4.png\\"],\\"datePublished\\":\\"2023-10-22T00:00:00.000Z\\",\\"dateModified\\":\\"2023-11-17T15:44:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[],"git":{"createdTime":1700232644000,"updatedTime":1700235854000,"contributors":[{"name":"azrng","username":"azrng","email":"itzhangyunpeng@163.com","commits":2}]},"readingTime":{"minutes":4.65,"words":1394},"filePathRelative":"dotnet/csharp/windowfuwu/netcorechuangjianwindowsfuwu.md","localizedDate":"2023年10月22日","excerpt":"<p><a href=\\"http://xn--2rqz13g.NET\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">使用.NET</a> Core创建Windows服务<br>\\n使用微软推荐方式<br>\\n使用Topshelf方式<br>\\n&nbsp;<br>\\n&nbsp;<br>\\n<strong>安装步骤</strong><br>\\n<a href=\\"http://xn--ykqpua31cv0dd80an4dw50e98lviy50bz27am4fvr4a.NET\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">这里首先你要确保你已经安装了.NET</a> Core 3.0或以上版本。在我编写这篇文章的时候， .NET Core 3.1刚刚发布，Visual Studio应该会提示你升级到最新版本。<a href=\\"http://xn--gqq5bs54a0qcguow0hbrcnv3i.NET\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">但是如果你想要在.NET</a> Core 2.x项目中使用这个方式，应该是行不通的。<br>\\n如果你喜欢使用命令行创建项目，你就需要使用工作器(worker)类型创建项目：<br>\\ndotnet new worker<br>\\n如果你是一个和我一样喜欢使用Visual Studio的开发人员，那么你可以在Visual Studio中使用项目模板完成相同的功能。<br>\\n<img src=\\"/common/1609838929172-9922ab7a-6416-4f10-8a28-f704b4f495f4.png\\" alt=\\"image.png\\" loading=\\"lazy\\"><br>\\n这样做将创建出一个包含两个文件的项目。其中Program.cs文件是应用的启动“引导程序”。另外一个文件是worker.cs文件，在这个文件中，你可以编写你的服务逻辑。<br>\\n这看起来应该是相当的容易，但是为这个程序添加额外的并行后台服务，你还需要添加一个类，并让它继承BackgroundService类:</p>","autoDesc":true}');export{c as comp,h as data};
