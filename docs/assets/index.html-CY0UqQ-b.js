import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as s,d as a}from"./app-CBxp4zeL.js";const i="/kbms/common/fad9fada-f1fc-44cb-8ad2-a6827b9bd714.png",l={},t=a('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>长久以来，我们程序员都是很好的技术型思考者，我们总是擅长从技术的角度来解决项目问题。但是，一个软件系统是否真正可用是通过它所提供的业务价值体现出来的。因此，与其每天钻在那些永远也学不完的技术中，何不将我们的关注点向软件系统所提供的业务价值方向思考思考，这也正是DDD所试图解决的问题。</p><figure><img src="'+i+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><blockquote><p>图片来源自：https://www.cnblogs.com/davenkin/p/ddd-in-plain-words.html</p></blockquote><h2 id="ddd战略设计" tabindex="-1"><a class="header-anchor" href="#ddd战略设计"><span>DDD战略设计</span></a></h2><p>不是一个单纯的技术工具集，不能仅仅局限于技术上的实现，过于拘泥于技术上的实现将会导致劣质的领域对象。DDD战略设计主要包括领域/子域、通用语言、界限上下文和架构风格等概念</p><p><code>战略设计只在解决一个问题，即软件的模块化划分的问题</code></p><p>在战略设计中，我们关注与从一个宏观的角度俯视整个软件系统，然后通过一定的原则对系统进行子域和界限上下文的划分。</p><h3 id="领域" tabindex="-1"><a class="header-anchor" href="#领域"><span>领域</span></a></h3><p>领域可以理解为一个组织要做的事情 划分为</p><ul><li>核心域：项目中核心的业务，和组织业务紧密关联起来</li><li>支撑域：项目中非核心的业务，和组织业务相关，但是不具有通用性</li><li>通用域：解决通用的问题，和组织业务无关</li></ul><p>领域(组织)的不同类型决定了公司的研发重点，通俗的说不同的公司同一个模块/领域可能属于不同的领域划分。</p><h3 id="子域" tabindex="-1"><a class="header-anchor" href="#子域"><span>子域</span></a></h3><p>表示领域中细分之后的子业务，是比领域更小的概念，子域又可以分为核心子域、支撑子域和通用子域</p><h3 id="界限上下文" tabindex="-1"><a class="header-anchor" href="#界限上下文"><span>界限上下文</span></a></h3><p>在一个领域/子域中，会创建一个概念上的领域边界，这个边界中，每个领域对象都标识在该边界内确切的含义，这个边界就是界限上下文。界限上下文和领域具有一对一的关系。通用语言要在特定的语义环境，只有确定了语言所在的便捷，才能没有歧义的描述一个业务。</p><p>在日常开发中，我们通常会将一个大型的软件系统拆分为若干个子系统，然后就可能遇到下面的问题。</p><p>问题一：当遇到一个领域概念建模在子系统A是可以的，但是建模在子系统B中似乎合乎情理</p><p>问题二：各个子系统之间如何进行集成？是像客户端调用服务端的那个样子吗，两个系统之间集成涉及到基础设施和不同领域概念在两个系统之间的翻译，这些概念容易对我们创建好的领域模型造成污染</p><p>如何解决上面的问题：答案就是界限上下文和上下文映射</p><h3 id="通用语言" tabindex="-1"><a class="header-anchor" href="#通用语言"><span>通用语言</span></a></h3><p>针对系统的理解不同导致的信息偏差，比如不同人对于删除的理解不同，逻辑删除和物理删除等，所以需要一个拥有确切含义、没有二义性的语言。</p><p>将一个界限上下文中的所有概念，包含名词、动词、和形容其全部集中在一起，我们就称为该界限上下文创建了一套通用语言。通用语言是一个团队所有成员交流时候所使用的语言，业务分析人员、编码人员和测试人员都应该通过通用语言进行交流</p><h3 id="架构风格" tabindex="-1"><a class="header-anchor" href="#架构风格"><span>架构风格</span></a></h3><p>DDD不要求采用特定的架构风格，它对架构是中立的，你可以采用三层式架构也可以采用REST架构和事件驱动架构等，但是在《实现领域驱动设计》中，作者更推崇使用事件驱动和六边形架构。</p><p>当前面向接口和依赖注入的原则已经颠覆了之前传统的三层架构，如果再进一步，那么便是六边形架构，也称为端口和适配器(Posts And Adapters)。在六边形架构中，已经不存在分层的概念，所有的组件都是平等的，这得益于软件抽象的好处，即各个组件之间的交互已经完全通过接口完成，而不是具体的实现细节。</p><p>现在常用的架构风格有六边形架构(洋葱架构)、整洁架构</p><h2 id="ddd战术设计" tabindex="-1"><a class="header-anchor" href="#ddd战术设计"><span>DDD战术设计</span></a></h2><p>如果说战略设计更偏向于软件架构，那么战术设计便更偏向于编码实现。DDD战术设计的目的是使得业务能够从技术中分离并突显出来，让代码直接表达业务的本身，其中包含了聚合根、应用服务、资源库、工厂等概念</p><h3 id="领域对象" tabindex="-1"><a class="header-anchor" href="#领域对象"><span>领域对象</span></a></h3><p>如果创造行为饱满的领域对象，这个时候我们需要转百年写思维，将领域对象当做是服务的提供方，而不仅仅是用来获取或者保存数据的容器，多思考一个领域对象能够提供哪些行为，而不是数据。</p><p>一个违背充血模型的实现：比如将本应该内聚在Order实体类的业务逻辑泄漏到其他地方(OrderService)，导致Order称为一个只是充当数据容器的贫血模型，而非真正意义上的领域模型。这会导致在项目的持续演进的过程中，这些业务逻辑会分散到不同的Service类中，最终的结果就是代码变得越来越你拿理解进而丧失扩展的能力。</p><h3 id="实体" tabindex="-1"><a class="header-anchor" href="#实体"><span>实体</span></a></h3><p>在一个软件系统中，实体表示那些具有生命周期并且在生命周期中发生改变的东西，一般表现形式就是EFCore中的实体类，拥有唯一标识，标识列不会发生改变，但是对象的其他状态则会经历各种变化。同一个概念，在不同的软件系统中可能会被建模成不同的内容，比如货币，在一个电商系统中，我们会将其建模为值对象，但是在一个管理发行货币的系统中，这个时候需要对每个货币进行跟踪，这个时候货币就变成了一个实体，并且有了唯一的标识</p><h4 id="标识符-identity" tabindex="-1"><a class="header-anchor" href="#标识符-identity"><span>标识符(Identity)</span></a></h4><p>用来定位一个对象，在数据库中一般使用实体的主键来实现标识符的效果，标识符用来跟踪对象状态的变化</p><p>实体中的唯一标识可以有多种的方式生成，有些业务数据天然就是唯一标识，比如对于人员来说，身份证号既可直接用于唯一标识，不过需要注意的就是，只有那些不变的业务字段才能用于唯一标识，否则当这些业务字段发生变更的时候，所有引用它的地方都需要做相应的更新。更多的时候我们建议采用一个无意义的ID来作为唯一标识，比如UUID或者通过雪花算法生成的ID等，但是由于UUID生成不是连续递增的，所以更偏向于使用雪花算法ID。</p><p>也可以使用数据库自增ID作为数据库的标识符，但是在DDD中不建议使用这些方式，因为这个方式创建出来的实体对象直到保存到数据库的最后一刻都是非法的，更好的方式是新建实体的时候就设置ID。且自增的ID在涉及多个项目合并等迁移数据时候会更麻烦。</p><h5 id="相等性判断" tabindex="-1"><a class="header-anchor" href="#相等性判断"><span>相等性判断</span></a></h5><p>实体对象通过ID进行相等性判断，而值对象通过自身携带的属性进行相等性判断，比如两个双胞胎，每个人都是一个实体对象，由于两个人身份证(唯一标识)不同，因此无论两个人长得多像，那均不能认为是同一个人；相反的，对于其中一个人来说，哪怕整容到面目全非，也依然是同一个人，因为他的ID始终没有发生变化。</p><p>在编码上，值对象需要实现<code>Equals</code>和<code>GetHashCode</code>方法，而实体一般不要，因为实体是通过ID来判断是否为同一个对象。</p><h5 id="可变性" tabindex="-1"><a class="header-anchor" href="#可变性"><span>可变性</span></a></h5><p>实体对象是可变的，而值对象是不可变的。对于实体对象而言，我们可以调用其上的方法直接修改其状态，；但是对于值对象来言，如果需要改变其状态，我们只能创建一个新的值对象，然后在新对象中包含改变后的状态。</p><h5 id="角色可变" tabindex="-1"><a class="header-anchor" href="#角色可变"><span>角色可变</span></a></h5><p>实体和值对象的划分不是一成不变的，而是根据其所处的界限上下文决定的，一个概念可能在这个上下文是实体对象，然后在另外的上下文中是一个值对象，比如货币，在日常交易活动中应该被建模为一个值对象，因为在对其抽象之后我们忽略了货币的颜色、编号等属性，而只关注其面值。但是如果哪天需要做一个系统来管理每一个货币，那么就需要根据货币的编号进行管理，这个时候货币就变成了一个实体对象。</p><h3 id="值对象-value-object" tabindex="-1"><a class="header-anchor" href="#值对象-value-object"><span>值对象(Value Object)</span></a></h3><p>在一个软件系统中，值对象表示起描述性作用的且可以相互替换的概念，值对象没有标识符，比如省市县信息，只是作为实体中的一个属性，值对象就像软件系统内的过客一样，具有“创建后不管”的特征，是不需要像关心实体那样子去关心诸如生命周期和持久化等问题，比如用户的地址信息、经纬度信息没有唯一的标识</p><p>值对象和实体的关系，值对象属于实体的一部分，体现的是整体和部分的关系</p><h4 id="值对象的好处" tabindex="-1"><a class="header-anchor" href="#值对象的好处"><span><strong>值对象的好处</strong></span></a></h4><ul><li>比实体更加简单</li><li>值对象同样可以可以包含业务逻辑，比如自己验证，这样子，无论何时我们拿到一个值对象的时候，都可以相信这是一个合法的对象。</li></ul><h3 id="聚合" tabindex="-1"><a class="header-anchor" href="#聚合"><span>聚合</span></a></h3><p>聚合体现的是现实世界中整体和部分的关系，比如订单和订单明细，整体封装了对部分的操作，两者有相同的生命周期，部分不会单独与外部系统单独交互，与外部系统的交互操作都是通过整体来处理的，也就是通过聚合根来进行处理。</p><p>目的：高内聚，低耦合，同一个模块内聚合度高，不通过模块之间的耦合度低。</p><p>判断标准 聚合的判断标准：实体是否存在整体和部分的关系，是否存在相同的声明周期(比如订单和订单详情，有订单就会有订单详情，没有订单就没有详情)</p><p>划分的原则 尽可能的将聚合设计小一点，一个聚合只包含一个聚合根实体和密不可分的实体，实体中只包含最小数量的属性。 小聚合有助于进行微服务的拆分。</p><p>业务逻辑处理 聚合中的实体中没有业务逻辑代码，只有对象的创建、对象的初始化、状态管理等个体相关的代码。 对于聚合内的业务逻辑，我们编写领域服务(Domain Service)，对于跨聚合协作以及聚合与外部系统协作的逻辑，我们应该编写应用服务(Application Service)，然后应用服务协调多个领域服务、外部系统来完成一个用例。</p><p>使用聚合的首要原则为一次事务中，最多只更改一个聚合的状态。如果一次业务操作涉及到了对多个聚合状态的更改，那么应该采用发布领域事件的方式通知相应的聚合。此时数据的一致性变为了最终一致性(比如在.Net中使用CAP框架去实现最终一致性)</p><h4 id="聚合根" tabindex="-1"><a class="header-anchor" href="#聚合根"><span>聚合根</span></a></h4><p>聚合根中的聚合是高内聚、低耦合中的内聚意思，而根是根部的意思。将紧密关联的一些实体类放到一个聚合中，每个聚合都有一个实体用来和外部的其他聚合进行交互，这个实体就是聚合根，外部的对象只能和聚合跟进行引用交互。聚合根不仅仅是一个实体，也是所在聚合的管理者。</p><p>聚合根也是实体，但与实体不同的是，聚合根是由实体和值对象组成的系统边界对象。举个例子来说，例如订单和订单项，根据业务逻辑，我们需要跟踪订单和订单项的状态，所以设计它们都为实体，但只有订单才是聚合根对象，而订单项不是，因为订单项只有在订单中才有意义，意思就是说：用户不能直接看到订单项，而是先查询到订单，然后再看到该订单下的订单项。所以聚合根可以理解为用户直接操作的对象。在这里商品类和类别类都是一个聚合根。一个概念是否能成为聚合根是根据所处的业务场景而定的。</p><p>聚合根之间的引用应该通过ID来完成：在聚合边界设计合理的情况下，一次业务用例只会去更新一个聚合根。</p><p>聚合根内部的所有变更都必须通过聚合根来完成：为了保证聚合根的一致性，同时避免聚合根内部逻辑往外泄露，客户方只能将整个聚合根作为统一调用的入口。</p><p>如果一个事务需要更新多个聚合根，那么就需要思考下自己的聚合根边界处理是否出现了问题，因为在设计合理的情况下通常不会出现一个事务更新多个聚合根的场景。如果这个场景确实是业务所需，那么应该考虑引入<code>消息机制</code>或者<code>事件驱动</code>架构，来保证一个事务只更新一个聚合根，然后通过消息机制异步更新其他聚合根。</p><p>聚合根的注意事项：</p><ul><li>聚合根不应该引用基础设施</li><li>外界不应该持有聚合根内部的数据结构</li><li>尽量使用小聚合</li></ul><h5 id="聚合根基类" tabindex="-1"><a class="header-anchor" href="#聚合根基类"><span>聚合根基类</span></a></h5><div class="language-c# line-numbers-mode" data-ext="c#" data-title="c#"><pre class="language-c#"><code>public abstract class AggregateRoot : IEquatable&lt;AggregateRoot&gt;
{
    public AggregateRoot()
    {
        // 使用第三方组件生成雪花id
        Id = YitIdHelper.NextId();
    }

    public static bool operator ==(AggregateRoot? first, AggregateRoot? second)
    {
        return first is not null &amp;&amp; second is not null &amp;&amp; first.Equals(second);
    }

    public static bool operator !=(AggregateRoot? first, AggregateRoot? second)
    {
        return !(first == second);
    }

    /// &lt;summary&gt;
    /// 聚合根id
    /// &lt;/summary&gt;
    public long Id { get; private init; }

    /// &lt;summary&gt;
    /// 创建者账号
    /// &lt;/summary&gt;
    public string Creater { get; set; }

    /// &lt;summary&gt;
    /// 创建时间
    /// &lt;/summary&gt;
    public DateTime CreateTime { get; set; }

    /// &lt;summary&gt;
    /// 修改人
    /// &lt;/summary&gt;
    public string Modifyer { get; set; }

    /// &lt;summary&gt;
    /// 修改时间
    /// &lt;/summary&gt;
    public DateTime ModifyTime { get; set; }

    /// &lt;summary&gt;
    /// 是否删除
    /// &lt;/summary&gt;
    public bool Deleted { get; set; } = false;

    /// &lt;summary&gt;
    /// 是否禁用
    /// &lt;/summary&gt;
    public bool Disabled { get; set; } = false;

    public override bool Equals(object? obj)
    {
        if (obj is null)
            return false;

        if (obj.GetType() != GetType())
            return false;

        if (obj is not AggregateRoot entity)
        {
            return false;
        }

        return entity.Id == Id;
    }

    public override int GetHashCode()
    {
        return Id.GetHashCode();
    }

    public bool Equals(AggregateRoot? other)
    {
        if (ReferenceEquals(null, other)) return false;
        if (ReferenceEquals(this, other)) return true;
        return Id == other.Id;
    }

    public long GetIdentifier()
    {
        return Id;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>AggregateRoot</code>中包含聚合根的ID、创建信息(创建人、创建时间)、更新信息(更新人、更新时间)，实际的聚合根继承自<code>AggregateRoot</code>，比如下面的员工聚合根</p><div class="language-c# line-numbers-mode" data-ext="c#" data-title="c#"><pre class="language-c#"><code>public sealed class Employee : AggregateRoot
{
    public Employee(string account, string password, string phone) : base()
    {
        Account = account;
        Password = password;
        Phone = phone;
    }

    public string Account { get; set; }

    public string Password { get; set; }

    public string Phone { get; set; }

    public Address Address { get; set; }

    public void ChangePassword(string newPassword, string oldPassword)
    {
        if (Password != oldPassword)
            throw new ArgumentException(&quot;密码无效&quot;);

        Password = newPassword;
    }

    public void ChangePhone(string phone)
    {
        Phone = phone;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="聚合根基本原则" tabindex="-1"><a class="header-anchor" href="#聚合根基本原则"><span>聚合根基本原则</span></a></h5><h6 id="内聚性原则" tabindex="-1"><a class="header-anchor" href="#内聚性原则"><span>内聚性原则</span></a></h6><p>聚合根内的属性都应该是该聚合根不可分割的属性，这些属性独立于该聚合根后无法独立存在</p><h6 id="对外黑盒原则" tabindex="-1"><a class="header-anchor" href="#对外黑盒原则"><span>对外黑盒原则</span></a></h6><p>聚合根的外部(也就是聚合根的调用方或者客户方)不需要关心聚合根内部的实现细节，只需要通过调用聚合根向外界暴漏的共有业务方法即可。具体是：外部对聚合根的调用只能通过调用聚合根内部的方法，而不能直接调用属性的公开<code>set</code>方法(直接将<code>set</code>方法设置为私有调用等)，具体代码实现如下</p><div class="language-c# line-numbers-mode" data-ext="c#" data-title="c#"><pre class="language-c#"><code>// Employee

public void ChangePassword(string newPassword, string oldPassword)
{
    if (Password != oldPassword)
        throw new ArgumentException(&quot;密码无效&quot;);

    Password = newPassword;
}

public void ChangePhone(string phone)
{
    Phone = phone;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当外部进行修改员工的密码或者手机号码的时候，需要调用该<code>Employee</code>的公共暴漏方法<code>ChangePassword</code>或<code>ChangePhone</code>。</p><h6 id="不变原则" tabindex="-1"><a class="header-anchor" href="#不变原则"><span>不变原则</span></a></h6><p>不变条件(Invariants)表示聚合根需要保证其内部在任何时候均处于一种合法的状态（也即数据一致性需要得到保证），一个常见的例子是订单(Order)中有订单项(OrderItem)和订单价格(Price)，当订单项发生变化时，其价格应该随之发生变化，并且这两种变化应该在订单的同一个业务方法中完成。这一点是好理解的，既然聚合根对外是一个黑盒，那么外界便不会负责给你聚合根擦屁股，你聚合根自己需要保证自身的正确性。</p><h6 id="通过id引用其他聚合根原则" tabindex="-1"><a class="header-anchor" href="#通过id引用其他聚合根原则"><span>通过ID引用其他聚合根原则</span></a></h6><p>当聚合根需要引用另一个聚合根的时候，并不需要维护对另一个聚合根的整体引用，而是只需要通过ID进行引用即可。这个原则的出发点是：聚合根和聚合根之间是一种平等的关系，并不是例数关系，每个聚合根本身就是一个相对独立的模块，并于其他聚合根之间的关系应该通过ID这种松耦合的方式进行引用，如果使用整体引用则就更像是一种包含的关系。</p><h6 id="与基础设施无关原则" tabindex="-1"><a class="header-anchor" href="#与基础设施无关原则"><span>与基础设施无关原则</span></a></h6><p>既然领域模型与基础设施无关，那么位于领域模型之内的聚合根自然也不能与基础设施相关，这样子的好处是将业务复杂度与技术复杂度解耦开，让业务模型可以独立于技术设施而完成自身的演变。方便以后如果迁移项目框架。</p><h5 id="跨聚合根用例" tabindex="-1"><a class="header-anchor" href="#跨聚合根用例"><span>跨聚合根用例</span></a></h5><p>一般情况一个业务用例只会操作一个聚合根，但是有时候一个业务用例可能会导致多个聚合根对象的更新，这个时候有下面两个情况</p><ul><li>如果聚合根位于不同的进程(不同的服务)中，那么解决方式可以使用分布式事务进行处理</li><li>如果聚合根位于同一个进程中，那么就可以使用本地事务来处理</li></ul><h3 id="领域服务" tabindex="-1"><a class="header-anchor" href="#领域服务"><span>领域服务</span></a></h3><p>对实体创建、初始化等操作在实体内处理，对于聚合内的业务逻辑在领域服务内处理(Domain Service)，可以理解为对聚合根的<code>辅助和补充</code></p><p>领域服务也不是必须的，在一些简单的业务处理中也可以是没有领域知识的，这个情况下应用服务就可以完成所有的操作，不需要引入领域服务。业务逻辑的代码尽量都放在聚合根或者聚合的边界之内，但是有时候有些逻辑不适合放在聚合根上，比如我们创建order的时候，这个时候需要去调用IdGenerattorService生成的ID，这时候就只好引入领域服务(Domain Service)来处理了，或者当一个逻辑无法通过单个实体来完成的时候，这个时候就需要使用领域服务来处理了</p><p>领域服务的应用示例，比如修改用户手机号码的时候，这时候要检查该手机号码是否已经被占用，所以此时该用户的聚合根自身不具备检查其他用户手机号码的功能，所以将这部分逻辑放到用户本身上就不太合适了，针对这个情况，DDD给出了专门的概念领域服务，领域服务是一个IE不得已而为之的概念，领域服务通常用于处理一些跨聚合操作或者需要访问技术基础设施的场景。在下面的实例中<code>检查密码是否正确</code>和<code>检查手机号码是否重复</code>都属于用户聚合根本身无法实现的功能</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">changeMyMobile</span><span class="token punctuation">(</span><span class="token class-name">Member</span> member<span class="token punctuation">,</span> <span class="token class-name">String</span> newMobile<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mryPasswordEncoder<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span>password<span class="token punctuation">,</span> member<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">MryException</span><span class="token punctuation">(</span><span class="token constant">PASSWORD_NOT_MATCH</span><span class="token punctuation">,</span>
                <span class="token string">&quot;修改手机号失败，密码不正确。&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;memberId&quot;</span><span class="token punctuation">,</span> member<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>member<span class="token punctuation">.</span><span class="token function">getMobile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> newMobile<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>memberRepository<span class="token punctuation">.</span><span class="token function">existsByMobile</span><span class="token punctuation">(</span>newMobile<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">MryException</span><span class="token punctuation">(</span><span class="token constant">MEMBER_WITH_MOBILE_ALREADY_EXISTS</span><span class="token punctuation">,</span>
                <span class="token string">&quot;修改手机号失败，手机号对应成员已存在。&quot;</span><span class="token punctuation">,</span>
                <span class="token function">mapOf</span><span class="token punctuation">(</span><span class="token string">&quot;mobile&quot;</span><span class="token punctuation">,</span> newMobile<span class="token punctuation">,</span>
                        <span class="token string">&quot;memberId&quot;</span><span class="token punctuation">,</span> member<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    member<span class="token punctuation">.</span><span class="token function">changeMobile</span><span class="token punctuation">(</span>newMobile<span class="token punctuation">,</span> member<span class="token punctuation">.</span><span class="token function">toUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="应用服务" tabindex="-1"><a class="header-anchor" href="#应用服务"><span>应用服务</span></a></h3><p>在聚合间的逻辑或者和外部系统的业务处理在应用服务进行处理(Application Servcie)应用服务用于协调多个领域服务、外部系统来完成一个用例，既然应用服务只是起协调代理的作用，也意味着应用服务不应该包含过多的逻辑，而应该是很薄的一层，领域模型与外部系统不会直接发生交互，也就是领域服务不会涉及数据库的操作，业务逻辑放在领域服务中，和外部系统的交互由应用服务来负责，应用服务不处理业务逻辑。</p><p>应用服务可以看到是领域模型的门面，它将接收到的请求派发给合适的领域模型去处理，在整个过程中，应用服务充当的是协调者和编排者的角色，就像是酒店的前台一样。</p><h3 id="领域事件和集成事件" tabindex="-1"><a class="header-anchor" href="#领域事件和集成事件"><span>领域事件和集成事件</span></a></h3><p>使用事件的目的：更新实体时候性能低时，使用异步更新，将需要更新的字段发送给领域事件，解决各个领域之间交互的问题(同步、异步)</p><p>领域事件(Domain Event) 在同一个微服务内的聚合之间的时间传递，使用进程内的通信机制来完成</p><p>集成事件 跨微服务的事件传递，使用事件总线进行实现</p><p>实现：发布订阅、消息队列</p><p>因为DDD的一个重要原则就是一次事务只更新一个聚合的实例，当的确需要修改多个聚合的业务用例时候，就需要使用领域事件来处理，此时使用最终一致性取代了事务一致性，通过领域事件的方式达到各个组件之间的数据一致性。</p><p>领域事件要从领域模型中发布，最终的接收者可以是本界限上下文内的也可以是另一个界限上下文的。</p><h3 id="仓储-资源库" tabindex="-1"><a class="header-anchor" href="#仓储-资源库"><span>仓储/资源库</span></a></h3><p>资源库可以理解为在内存中维护一系列聚合根的集合，这里资源库以聚合根为单位，也只有聚合根才配得上拥有资源库，其他对象(比如非聚合根实体)是没有对应资源库的，而聚合根不可能一直存在于内存中，当它不活动时会被持久化到数据中。而仓储层完成的任务是持久化聚合根对象到数据或从数据库中查询存储的对象来重新创建领域对象。</p><p>所有的实体都可以有相应的DAO，但并不是所有的实体都有资源库，只有聚合根才有相应的资源库。资源库用来从数据库读取数据以及将实体的修改保存到数据库中。</p><p>资源库的作用：在于在业务复杂度和技术复杂度之间做了一层很好的隔离，可以让我们独立看待软件的业务模型而不受技术设施的影响。从本质上讲，资源库做的事情就是实现数据在内存和磁盘之间的相互传输。</p><p>在DDD项目中，通常讲资源库分为接口类和实现类，将接口类放置在领域模型<code>Domain</code>层中，然后将实现类放置在基础设施层<code>Infrastructure</code>中，这样子的好处有</p><ul><li>通过依赖反转，使得领域模型不依赖基础设施</li><li>实现资源库的可拔插性，比如未来需要从MongoDb迁移到MySQL中，那么就需要创建新的实现类即可</li></ul><h2 id="事务脚本" tabindex="-1"><a class="header-anchor" href="#事务脚本"><span>事务脚本</span></a></h2><p>不建议的写法</p><p>像写流水账一样进行写代码(面向过程)，风格就是先干嘛再干嘛，然后再干嘛</p><h2 id="防腐层" tabindex="-1"><a class="header-anchor" href="#防腐层"><span>防腐层</span></a></h2><p>解决上文中提到的各个子域之间集成的问题，其实也是界限上下文之间集成的问题，在集成的时候我们需要关心领域模型和集成手段之间的关系，这个时候就需要使用到防腐层，该层负责与外部服务打交道，还负责将外部概念翻译为自己核心领域能够理解的概念，防腐层只是界限上下文之间集成的方式之一。</p><h2 id="工作单元" tabindex="-1"><a class="header-anchor" href="#工作单元"><span>工作单元</span></a></h2><p>聚合内的若干先相关的操作组成一个工作单元，这些操作要不全部成功，要不全部失败。</p><h2 id="规约-specification" tabindex="-1"><a class="header-anchor" href="#规约-specification"><span>规约(Specification)</span></a></h2><p>对实体的过滤 对单个实体进行规定约束，主要是针对属性。 对集合实体进行规定约束，主要是针对集合过滤。</p><h2 id="数据完整性" tabindex="-1"><a class="header-anchor" href="#数据完整性"><span>数据完整性</span></a></h2><p>比如有一个请求的数据异步需要做一些处理后才可用，这个时候不应该先将数据插入到表中(在表中设置某一个状态为不可用)，而应该将该数据存储到redis或者其他地方，然后等待数据解析或者处理完成的时候才插入数据库中，这样子就保证了数据的完整性(也避免了代码中很多地方包含是否可用等逻辑判断)</p><h2 id="cqrs" tabindex="-1"><a class="header-anchor" href="#cqrs"><span>CQRS</span></a></h2><p>CQRS直译中文叫做命令查询职责分离，也叫做读写分离的意思，不过这里的读写分离不是通常理解饿数据库级别的读写分离，这里指的是在应用程序内部代码级别的读写分离。</p><h3 id="流程分离" tabindex="-1"><a class="header-anchor" href="#流程分离"><span>流程分离</span></a></h3><p>读写的流程分离</p><h3 id="模型分离" tabindex="-1"><a class="header-anchor" href="#模型分离"><span>模型分离</span></a></h3><p>在写数据的时候，严格按照领域模型对业务逻辑的请求处理流程，但是在读数据的时候，可以绕过领域模型，直接从数据库创建相应的读模型对象。具体到编码上，在写数据测可能通过ORM等工具完成对聚合根的持久化，但是在读数据测那么可以直接通过SQL语句从数据库加载所需的查询数据。</p><h3 id="数据源分离" tabindex="-1"><a class="header-anchor" href="#数据源分离"><span>数据源分离</span></a></h3><p>专门为查询单独创建一个数据库，这个数据库存在的目的仅仅是为了方便查询使用，可以说是为了读数据测量身定做的，该数据库中的数据依然来自写数据的一侧。然后可以通过代码或者数据库的主从模式同步到从库。</p><h2 id="资料" tabindex="-1"><a class="header-anchor" href="#资料"><span>资料</span></a></h2><p>DDD概念大白话：https://www.cnblogs.com/davenkin/p/ddd-in-plain-words.html</p><p>应用服务和领域服务：https://www.cnblogs.com/davenkin/p/ddd-application-service-and-domain-service.html</p><p>领域事件：https://www.cnblogs.com/davenkin/p/ddd-domain-events.html</p><p>CQRS：https://www.cnblogs.com/davenkin/p/ddd-cqrs.html</p>`,130),d=[t];function c(p,r){return e(),s("div",null,d)}const v=n(l,[["render",c],["__file","index.html.vue"]]),m=JSON.parse('{"path":"/softwareDesign/domainDrivenDesign/commonConcept/","title":"常用概念","lang":"zh-CN","frontmatter":{"title":"常用概念","lang":"zh-CN","date":"2023-08-19T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["软件设计"],"tag":["无"],"filename":"changyonggainian","slug":"wfyo9p","docsId":"50617595","description":"前言 长久以来，我们程序员都是很好的技术型思考者，我们总是擅长从技术的角度来解决项目问题。但是，一个软件系统是否真正可用是通过它所提供的业务价值体现出来的。因此，与其每天钻在那些永远也学不完的技术中，何不将我们的关注点向软件系统所提供的业务价值方向思考思考，这也正是DDD所试图解决的问题。 imgimg 图片来源自：https://www.cnblog...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/softwareDesign/domainDrivenDesign/commonConcept/"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"常用概念"}],["meta",{"property":"og:description","content":"前言 长久以来，我们程序员都是很好的技术型思考者，我们总是擅长从技术的角度来解决项目问题。但是，一个软件系统是否真正可用是通过它所提供的业务价值体现出来的。因此，与其每天钻在那些永远也学不完的技术中，何不将我们的关注点向软件系统所提供的业务价值方向思考思考，这也正是DDD所试图解决的问题。 imgimg 图片来源自：https://www.cnblog..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://azrng.gitee.io/kbms/kbms/common/fad9fada-f1fc-44cb-8ad2-a6827b9bd714.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-15T09:18:41.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-08-19T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-02-15T09:18:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"常用概念\\",\\"image\\":[\\"https://azrng.gitee.io/kbms/kbms/common/fad9fada-f1fc-44cb-8ad2-a6827b9bd714.png\\"],\\"datePublished\\":\\"2023-08-19T00:00:00.000Z\\",\\"dateModified\\":\\"2024-02-15T09:18:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"DDD战略设计","slug":"ddd战略设计","link":"#ddd战略设计","children":[{"level":3,"title":"领域","slug":"领域","link":"#领域","children":[]},{"level":3,"title":"子域","slug":"子域","link":"#子域","children":[]},{"level":3,"title":"界限上下文","slug":"界限上下文","link":"#界限上下文","children":[]},{"level":3,"title":"通用语言","slug":"通用语言","link":"#通用语言","children":[]},{"level":3,"title":"架构风格","slug":"架构风格","link":"#架构风格","children":[]}]},{"level":2,"title":"DDD战术设计","slug":"ddd战术设计","link":"#ddd战术设计","children":[{"level":3,"title":"领域对象","slug":"领域对象","link":"#领域对象","children":[]},{"level":3,"title":"实体","slug":"实体","link":"#实体","children":[{"level":4,"title":"标识符(Identity)","slug":"标识符-identity","link":"#标识符-identity","children":[{"level":5,"title":"相等性判断","slug":"相等性判断","link":"#相等性判断","children":[]},{"level":5,"title":"可变性","slug":"可变性","link":"#可变性","children":[]},{"level":5,"title":"角色可变","slug":"角色可变","link":"#角色可变","children":[]}]}]},{"level":3,"title":"值对象(Value Object)","slug":"值对象-value-object","link":"#值对象-value-object","children":[{"level":4,"title":"值对象的好处","slug":"值对象的好处","link":"#值对象的好处","children":[]}]},{"level":3,"title":"聚合","slug":"聚合","link":"#聚合","children":[{"level":4,"title":"聚合根","slug":"聚合根","link":"#聚合根","children":[{"level":5,"title":"聚合根基类","slug":"聚合根基类","link":"#聚合根基类","children":[]},{"level":5,"title":"聚合根基本原则","slug":"聚合根基本原则","link":"#聚合根基本原则","children":[]},{"level":5,"title":"跨聚合根用例","slug":"跨聚合根用例","link":"#跨聚合根用例","children":[]}]}]},{"level":3,"title":"领域服务","slug":"领域服务","link":"#领域服务","children":[]},{"level":3,"title":"应用服务","slug":"应用服务","link":"#应用服务","children":[]},{"level":3,"title":"领域事件和集成事件","slug":"领域事件和集成事件","link":"#领域事件和集成事件","children":[]},{"level":3,"title":"仓储/资源库","slug":"仓储-资源库","link":"#仓储-资源库","children":[]}]},{"level":2,"title":"事务脚本","slug":"事务脚本","link":"#事务脚本","children":[]},{"level":2,"title":"防腐层","slug":"防腐层","link":"#防腐层","children":[]},{"level":2,"title":"工作单元","slug":"工作单元","link":"#工作单元","children":[]},{"level":2,"title":"规约(Specification)","slug":"规约-specification","link":"#规约-specification","children":[]},{"level":2,"title":"数据完整性","slug":"数据完整性","link":"#数据完整性","children":[]},{"level":2,"title":"CQRS","slug":"cqrs","link":"#cqrs","children":[{"level":3,"title":"流程分离","slug":"流程分离","link":"#流程分离","children":[]},{"level":3,"title":"模型分离","slug":"模型分离","link":"#模型分离","children":[]},{"level":3,"title":"数据源分离","slug":"数据源分离","link":"#数据源分离","children":[]}]},{"level":2,"title":"资料","slug":"资料","link":"#资料","children":[]}],"git":{"createdTime":1693926838000,"updatedTime":1707988721000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":8},{"name":"zhangyunpeng","email":"zhang.yunpeng@synyi.com","commits":1}]},"readingTime":{"minutes":23.89,"words":7166},"filePathRelative":"softwareDesign/domainDrivenDesign/commonConcept/readme.md","localizedDate":"2023年8月19日","excerpt":"<h2>前言</h2>\\n<p>长久以来，我们程序员都是很好的技术型思考者，我们总是擅长从技术的角度来解决项目问题。但是，一个软件系统是否真正可用是通过它所提供的业务价值体现出来的。因此，与其每天钻在那些永远也学不完的技术中，何不将我们的关注点向软件系统所提供的业务价值方向思考思考，这也正是DDD所试图解决的问题。</p>\\n<figure><img src=\\"/common/fad9fada-f1fc-44cb-8ad2-a6827b9bd714.png\\" alt=\\"img\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>img</figcaption></figure>","autoDesc":true}');export{v as comp,m as data};
