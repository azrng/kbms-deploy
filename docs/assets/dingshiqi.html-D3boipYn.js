import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,d as i,o as n}from"./app-fQkBsvt-.js";const a={};function m(o,e){return n(),r("div",null,e[0]||(e[0]=[i("<p>System.Threading.Timer定时器，可以定时循环执行一个任务，是在线程上面执行的，具有很少的安全性。他不建议使用Windows窗体，因为他的回调不会在用户界面线程上发生。<br> 定义一个定时变量器<br> static System.Threading.Timer timer;<br> 创建一个定时器<br> timer = new System.Threading.Timer(chang, null, 5000, 2000);<br> 第一个是调用的方法，第三个是多久以后开始调用，第四个是隔多久调用一次<br> 关闭定时器<br> timer.Dispose();<br>  <br> System.Windows.Forms.Timer 是使用 Windows 窗体的更好选择。 对于基于服务器的计时器的功能。<br>  <br> 对于基于服务器的计时器的功能，您可以考虑使用 System.Timers.Timer, ，它将引发事件，并具有附加功能。</p>",1)]))}const g=t(a,[["render",m],["__file","dingshiqi.html.vue"]]),c=JSON.parse('{"path":"/dotnet/webyingyong/webform/xiancheng/dingshiqi.html","title":"定时器","lang":"zh-CN","frontmatter":{"title":"定时器","lang":"zh-CN","date":"2021-02-17T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["dotNET"],"tag":["无"],"filename":"dingshiqi","slug":"ggrw36","docsId":"31541461","description":"System.Threading.Timer定时器，可以定时循环执行一个任务，是在线程上面执行的，具有很少的安全性。他不建议使用Windows窗体，因为他的回调不会在用户界面线程上发生。 定义一个定时变量器 static System.Threading.Timer timer; 创建一个定时器 timer = new System.Threading...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dotnet/webyingyong/webform/xiancheng/dingshiqi.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"定时器"}],["meta",{"property":"og:description","content":"System.Threading.Timer定时器，可以定时循环执行一个任务，是在线程上面执行的，具有很少的安全性。他不建议使用Windows窗体，因为他的回调不会在用户界面线程上发生。 定义一个定时变量器 static System.Threading.Timer timer; 创建一个定时器 timer = new System.Threading..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-22T08:11:43.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2021-02-17T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-10-22T08:11:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"定时器\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-02-17T00:00:00.000Z\\",\\"dateModified\\":\\"2023-10-22T08:11:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[],"git":{"createdTime":1697962303000,"updatedTime":1697962303000,"contributors":[{"name":"azrng","username":"azrng","email":"itzhangyunpeng@163.com","commits":1}]},"readingTime":{"minutes":0.71,"words":212},"filePathRelative":"dotnet/webyingyong/webform/xiancheng/dingshiqi.md","localizedDate":"2021年2月17日","excerpt":"<p>System.Threading.Timer定时器，可以定时循环执行一个任务，是在线程上面执行的，具有很少的安全性。他不建议使用Windows窗体，因为他的回调不会在用户界面线程上发生。<br>\\n定义一个定时变量器<br>\\nstatic System.Threading.Timer timer;<br>\\n创建一个定时器<br>\\ntimer = new System.Threading.Timer(chang, null, 5000, 2000);<br>\\n第一个是调用的方法，第三个是多久以后开始调用，第四个是隔多久调用一次<br>\\n关闭定时器<br>\\ntimer.Dispose();<br>\\n&nbsp;<br>\\nSystem.Windows.Forms.Timer 是使用 Windows 窗体的更好选择。 对于基于服务器的计时器的功能。<br>\\n&nbsp;<br>\\n对于基于服务器的计时器的功能，您可以考虑使用 System.Timers.Timer, ，它将引发事件，并具有附加功能。</p>","autoDesc":true}');export{g as comp,c as data};
