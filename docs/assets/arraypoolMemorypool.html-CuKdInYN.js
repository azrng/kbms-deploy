import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,o as a,d as e}from"./app-2OrQE2Jp.js";const l="/kbms/common/1619855963637-722690b1-54c7-4e74-bf67-1c79024eff2d.png",n="/kbms/common/1619855963561-fdb20396-e50c-445e-9c63-b2bb987fe5a7.png",r={},t=e(`<blockquote><p>参考文档：<a href="https://mp.weixin.qq.com/s/u3Ve-zeR0GymxDKRFQRNZg" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/u3Ve-zeR0GymxDKRFQRNZg</a></p></blockquote><h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍"><span>介绍</span></a></h2><p>对资源的可复用是提升应用程序性能的一个非常重要的手段，比如本篇要分享的 ArrayPool 和 MemoryPool，它们就有效的减少了内存使用和对GC的压力，从而提升应用程序性能。</p><h2 id="arraypoll" tabindex="-1"><a class="header-anchor" href="#arraypoll"><span>ArrayPoll</span></a></h2><h3 id="什么是arraypoll" tabindex="-1"><a class="header-anchor" href="#什么是arraypoll"><span>什么是ArrayPoll</span></a></h3><p>System.Buffers 命名空间下提供了一个可对 array 进行复用的高性能池化类 <code>ArrayPool&lt;T&gt;</code>，在经常使用 array 的场景下可使用 <code>ArrayPool&lt;T&gt;</code> 来减少内存占用,它是一个抽象类，如下代码所示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>public abstract class ArrayPool&lt;T&gt;</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以想象一下你的业务场景中需要多次实例化 array，这么做有什么后果呢？很显然每一次 new array 都会在托管堆上分配，同时当 array 不再使用时还需要 GC 去释放，而 <code>ArrayPool&lt;T&gt;</code> 就是为了解决此事而生的，它在池中动态维护若干个 array 对象，当你需要 <code>new array</code> 的时候只需从池中获取即可。</p><h3 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h3><p><code>ArrayPool&lt;T&gt;</code> 的主要用途是在需要频繁创建和释放数组的情况下，提高性能和减少内存开销。以下是一些常见的使用场景：</p><ol><li>高性能的数据处理：当你需要处理大量数据并频繁创建和释放数组时，使用 <code>ArrayPool&lt;T&gt;</code> 可以避免频繁的垃圾回收和内存分配，从而提高性能。这对于需要快速处理图像、音频、视频等大型数据集的应用程序特别有用。</li><li>网络编程：在网络编程中，经常需要处理和传输大量的字节数据。使用 <code>ArrayPool&lt;T&gt;</code> 可以减少内存碎片和垃圾回收，提高网络数据的处理效率。</li><li>数据库操作：当进行数据库读写或批处理操作时，可能需要频繁地创建和释放数组来作为缓冲区或临时存储区。使用 <code>ArrayPool&lt;T&gt;</code> 可以减少内存分配和垃圾回收的开销，提高数据库操作的效率。</li><li>并行和多线程编程：在并行和多线程编程中，为每个线程分配一个私有的数组池实例，可以避免线程之间的竞争和锁的开销。这样可以更好地利用多核处理器，并提高并发性能。</li></ol><p>需要注意的是，在使用 <code>ArrayPool&lt;T&gt;</code> 时，一定要正确地租借和归还数组，以避免资源泄漏和内存错误。确保在使用完数组后及时调用 Return() 方法将其归还给数组池。</p><h3 id="常用方法" tabindex="-1"><a class="header-anchor" href="#常用方法"><span>常用方法</span></a></h3><h4 id="create和shared" tabindex="-1"><a class="header-anchor" href="#create和shared"><span>Create和Shared</span></a></h4><ol><li><code>ArrayPool&lt;T&gt;</code>.Create() 方法：这是一个静态方法，用于创建一个新的数组池实例。每次调用该方法都会创建一个全新的数组池，该数组池具有独立的资源和配置。这意味着每个调用 <code>ArrayPool&lt;T&gt;</code>.Create() 的地方都会创建一个不同的数组池实例，彼此之间没有共享。</li><li><code>ArrayPool&lt;T&gt;</code>.Shared 属性：这是一个静态属性，用于获取全局共享的数组池实例。在整个应用程序域中，只会存在一个共享的数组池实例。多个线程可以共享使用这个实例，以便在需要分配和回收数组时更高效地利用内存资源。</li></ol><p>两者的主要区别如下：</p><ul><li>创建方式：<code>ArrayPool&lt;T&gt;</code>.Create() 创建一个新的数组池实例，而 <code>ArrayPool&lt;T&gt;</code>.Shared 获取全局共享的数组池实例。</li><li>实例数：<code>ArrayPool&lt;T&gt;</code>.Create() 每次调用创建一个新的实例，而 <code>ArrayPool&lt;T&gt;</code>.Shared 只有一个全局共享实例。</li><li>作用范围：<code>ArrayPool&lt;T&gt;</code>.Create() 的作用范围是调用它的代码块或对象，而 <code>ArrayPool&lt;T&gt;</code>.Shared 在整个应用程序域中有效。</li></ul><p>如果你需要在特定的代码块或对象中管理数组池，可以使用 <code>ArrayPool&lt;T&gt;</code>.Create() 来创建一个专用的实例。而如果你需要在整个应用程序域中共享和重复使用数组池，可以使用 <code>ArrayPool&lt;T&gt;</code>.Shared 来获取全局共享的实例。共享的实例可以提高性能并减少资源消耗，但需要注意合理使用，避免滥用和浪费资源。</p><h4 id="rent" tabindex="-1"><a class="header-anchor" href="#rent"><span>Rent</span></a></h4><p>在 <code>ArrayPool&lt;T&gt;</code> 中，Rent() 方法用于从数组池中租借一个数组，并指定所需的长度。然而，租借的数组的实际长度可能会超过所需的长度。这是因为 <code>ArrayPool&lt;T&gt;</code> 内部维护了一组预分配的数组池，以便更高效地管理内存。 具体来说，<code>ArrayPool&lt;T&gt;</code> 倾向于分配的数组长度是按照某种预定义的规则进行调整的。这种行为可以最大程度地减少内存碎片化，并在一定程度上提高内存利用率。 对于常见的数组大小，例如小于 85 元素的情况，实际分配的数组大小是根据以下规则选择的：</p><ul><li>如果请求的长度小于等于 16，分配一个长度为 16 的数组。</li><li>如果请求的长度大于 16，但小于等于 32，分配一个长度为 32 的数组。</li><li>如果请求的长度大于 32，但小于等于 64，分配一个长度为 64 的数组。</li><li>如果请求的长度大于 64，但小于等于 128，分配一个长度为 128 的数组。</li></ul><p>这样做的目的是为了避免频繁分配和回收小数组所带来的性能开销，以及减少内存碎片。</p><h3 id="使用-arraypool-t" tabindex="-1"><a class="header-anchor" href="#使用-arraypool-t"><span>使用 <code>ArrayPool&lt;T&gt;</code></span></a></h3><p>可以通过下面三种方式来使用 <code>ArrayPool&lt;T&gt;</code> 。</p><ul><li>通过 <code>ArrayPool&lt;T&gt;.Shared</code> 属性来获取 <code>ArrayPool&lt;T&gt;</code> 实例。</li><li>通过 <code>ArrayPool&lt;T&gt;.Create()</code> 来生成 <code>ArrayPool&lt;T&gt;</code> 实例。</li><li>通过继承 <code>ArrayPool&lt;T&gt;</code> 来生成一个自定义子类。</li></ul><p>下面的代码展示了如何从 ArrayPool 中获取一个 <code>size &gt;= 10</code> 的 array 数组。</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> shared</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> ArrayPool</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Shared</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> rentedArray</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> shared</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Rent</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+l+`" alt="" loading="lazy"> 上面的代码一定要注意，虽然只租用了 10 个 size，但底层会返回 <code>2的倍数</code>  的size , 也就是图中的 2* 8 = 16。 当什么时候不需要 rentedArray 了，记得再将它归还到 ArrayPool 中，如下代码所示。</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">shared</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Return</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">rentedArray</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>下面是仅供参考的完整代码。</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Main</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> shared</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> ArrayPool</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Shared</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> rentedArray</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> shared</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Rent</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">17</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">	Console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">WriteLine</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">$&quot;当前大小：{</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">rentedArray</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Length</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">}   没有和所需大小一样是因为内部维护了一组预分配的数组池&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	for</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">i</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">i</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">	{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">		rentedArray</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">i</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">	}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	for</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> j</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">j</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">j</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">	{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">		Console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">WriteLine</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">rentedArray</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">j</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">	shared</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Return</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">rentedArray</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="创建自定义的-arraypool" tabindex="-1"><a class="header-anchor" href="#创建自定义的-arraypool"><span>创建自定义的 ArrayPool</span></a></h3><p>你也可以通过重写 ArrayPool 来实现自定义的池化对象，如下代码所示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>public class CustomArrayPool&lt;T&gt; : ArrayPool&lt;T&gt;</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>        public override T[] Rent(int minimumLength)</span></span>
<span class="line"><span>        {</span></span>
<span class="line"><span>            throw new NotImplementedException();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        public override void Return(T[] array, bool clearArray = false)</span></span>
<span class="line"><span>        {</span></span>
<span class="line"><span>            throw new NotImplementedException();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="memorypool" tabindex="-1"><a class="header-anchor" href="#memorypool"><span>MemoryPool</span></a></h2><h3 id="使用memorypool-t" tabindex="-1"><a class="header-anchor" href="#使用memorypool-t"><span><code>使用MemoryPool&lt;T&gt;</code></span></a></h3><p><code>System.Memory</code> 命名空间下提供了一个内存池对象 <code>MemoryPool&lt;T&gt;</code>，在这之前你需要每次都 new 一个内存块出来，同时也增加了 GC 的负担，有了 <code>MemoryPool&lt;T&gt;</code> 之后，你需要的内存块直接从池中拿就可以了。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>static void Main(string[] args)</span></span>
<span class="line"><span>        {</span></span>
<span class="line"><span>            var  memoryPool = MemoryPool&lt;int&gt;.Shared;</span></span>
<span class="line"><span>            var rentedArray = memoryPool.Rent(10);</span></span>
<span class="line"><span>            for (int i = 0; i &lt; 10; i++)</span></span>
<span class="line"><span>            {</span></span>
<span class="line"><span>                rentedArray.Memory.Span[i] = i + 1;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            for (int j = 0; j &lt; 10; j++)</span></span>
<span class="line"><span>            {</span></span>
<span class="line"><span>                Console.WriteLine(rentedArray.Memory.Span[j]);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            Console.ReadKey();</span></span>
<span class="line"><span>        }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="arraypool-t-vs-memorypool-t" tabindex="-1"><a class="header-anchor" href="#arraypool-t-vs-memorypool-t"><span><code>ArrayPool&lt;T&gt;</code> vs <code>MemoryPool&lt;T&gt;</code></span></a></h2><p>从上面的演示可以看出， <code>ArrayPool&lt;T&gt;</code> 是以 <code>array</code> 的形式向外租借，而 <code>MemoryPool&lt;T&gt;</code> 则是以 <code>内存块</code> 的方式向外租借，所以在重复使用 array 的场景下可以优选 <code>ArrayPool&lt;T&gt;</code> 来提高性能，如果你的代码是以 <code>Memory&lt;T&gt;</code> 这种内存块的形式多次使用则优先使用 <code>MemoryPool&lt;T&gt;</code>。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><p>资料来源：<a href="https://mp.weixin.qq.com/s/u3Ve-zeR0GymxDKRFQRNZg" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/u3Ve-zeR0GymxDKRFQRNZg</a></p>',43),p=[t];function h(o,d){return a(),i("div",null,p)}const y=s(r,[["render",h],["__file","arraypoolMemorypool.html.vue"]]),g=JSON.parse('{"path":"/dotnet/csharp/jigecaozuo/kuozhan/arraypoolMemorypool.html","title":"ArrayPool和MemoryPool","lang":"zh-CN","frontmatter":{"title":"ArrayPool和MemoryPool","lang":"zh-CN","date":"2023-10-22T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["csharp"],"tag":["无"],"filename":"arraypoolMemorypool.md","slug":"oeyqtg","docsId":"32486346","description":"参考文档：https://mp.weixin.qq.com/s/u3Ve-zeR0GymxDKRFQRNZg 介绍 对资源的可复用是提升应用程序性能的一个非常重要的手段，比如本篇要分享的 ArrayPool 和 MemoryPool，它们就有效的减少了内存使用和对GC的压力，从而提升应用程序性能。 ArrayPoll 什么是ArrayPoll Syst...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dotnet/csharp/jigecaozuo/kuozhan/arraypoolMemorypool.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"ArrayPool和MemoryPool"}],["meta",{"property":"og:description","content":"参考文档：https://mp.weixin.qq.com/s/u3Ve-zeR0GymxDKRFQRNZg 介绍 对资源的可复用是提升应用程序性能的一个非常重要的手段，比如本篇要分享的 ArrayPool 和 MemoryPool，它们就有效的减少了内存使用和对GC的压力，从而提升应用程序性能。 ArrayPoll 什么是ArrayPoll Syst..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://azrng.gitee.io/kbms/kbms/common/1619855963637-722690b1-54c7-4e74-bf67-1c79024eff2d.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-11-17T15:44:14.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-10-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-11-17T15:44:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ArrayPool和MemoryPool\\",\\"image\\":[\\"https://azrng.gitee.io/kbms/kbms/common/1619855963637-722690b1-54c7-4e74-bf67-1c79024eff2d.png\\",\\"https://azrng.gitee.io/kbms/kbms/common/1619855963561-fdb20396-e50c-445e-9c63-b2bb987fe5a7.png\\"],\\"datePublished\\":\\"2023-10-22T00:00:00.000Z\\",\\"dateModified\\":\\"2023-11-17T15:44:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"介绍","slug":"介绍","link":"#介绍","children":[]},{"level":2,"title":"ArrayPoll","slug":"arraypoll","link":"#arraypoll","children":[{"level":3,"title":"什么是ArrayPoll","slug":"什么是arraypoll","link":"#什么是arraypoll","children":[]},{"level":3,"title":"使用场景","slug":"使用场景","link":"#使用场景","children":[]},{"level":3,"title":"常用方法","slug":"常用方法","link":"#常用方法","children":[{"level":4,"title":"Create和Shared","slug":"create和shared","link":"#create和shared","children":[]},{"level":4,"title":"Rent","slug":"rent","link":"#rent","children":[]}]},{"level":3,"title":"使用 ArrayPool<T>","slug":"使用-arraypool-t","link":"#使用-arraypool-t","children":[]},{"level":3,"title":"创建自定义的 ArrayPool","slug":"创建自定义的-arraypool","link":"#创建自定义的-arraypool","children":[]}]},{"level":2,"title":"MemoryPool","slug":"memorypool","link":"#memorypool","children":[{"level":3,"title":"使用MemoryPool<T>","slug":"使用memorypool-t","link":"#使用memorypool-t","children":[]}]},{"level":2,"title":"ArrayPool<T> vs MemoryPool<T>","slug":"arraypool-t-vs-memorypool-t","link":"#arraypool-t-vs-memorypool-t","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1700232644000,"updatedTime":1700235854000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":1}]},"readingTime":{"minutes":6.55,"words":1966},"filePathRelative":"dotnet/csharp/jigecaozuo/kuozhan/arraypoolMemorypool.md","localizedDate":"2023年10月22日","excerpt":"<blockquote>\\n<p>参考文档：<a href=\\"https://mp.weixin.qq.com/s/u3Ve-zeR0GymxDKRFQRNZg\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://mp.weixin.qq.com/s/u3Ve-zeR0GymxDKRFQRNZg</a></p>\\n</blockquote>\\n<h2>介绍</h2>\\n<p>对资源的可复用是提升应用程序性能的一个非常重要的手段，比如本篇要分享的 ArrayPool 和 MemoryPool，它们就有效的减少了内存使用和对GC的压力，从而提升应用程序性能。</p>","autoDesc":true}');export{y as comp,g as data};
