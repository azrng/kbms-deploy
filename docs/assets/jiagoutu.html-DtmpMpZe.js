import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,d as t,o as n}from"./app-DaCCUZLQ.js";const i="/kbms/common/1624497455143-104691ec-981b-435c-b6db-3389013aed54.webp",s="/kbms/softwareDesign/73c1f13202d127de8ac7c544b112111.jpg",r={};function p(h,e){return n(),l("div",null,e[0]||(e[0]=[t('<h2 id="架构图" tabindex="-1"><a class="header-anchor" href="#架构图"><span>架构图</span></a></h2><p><img src="'+i+'" alt=""></p><p>这个图我感觉挺对，聚合服务层根据情况使用</p><h2 id="架构示例" tabindex="-1"><a class="header-anchor" href="#架构示例"><span>架构示例</span></a></h2><h3 id="前端" tabindex="-1"><a class="header-anchor" href="#前端"><span>前端</span></a></h3><p>ES6、Vue全家桶、Element UI、Sass、axios、dayjs、echarts</p><h3 id="后端" tabindex="-1"><a class="header-anchor" href="#后端"><span>后端</span></a></h3><p>.Net Core、EFCore、JWT、RabbitMq、Swagger、WebSocket</p><h3 id="数据库" tabindex="-1"><a class="header-anchor" href="#数据库"><span>数据库</span></a></h3><p>MySQL、postgres、sqlserver、oracle、达梦数据库、人大金仓</p><h3 id="数据缓存" tabindex="-1"><a class="header-anchor" href="#数据缓存"><span>数据缓存</span></a></h3><p>redis</p><h3 id="文件存储" tabindex="-1"><a class="header-anchor" href="#文件存储"><span>文件存储</span></a></h3><p>本地存储、Minio、OSS</p><h3 id="中间件" tabindex="-1"><a class="header-anchor" href="#中间件"><span>中间件</span></a></h3><p>Nacos(服务发现、服务配置)、Consul、Skywalking、Es、logstash、Kibana</p><h3 id="devops" tabindex="-1"><a class="header-anchor" href="#devops"><span>Devops</span></a></h3><p>GitLab、Jenkins、Harbor(私有镜像仓库)、Nexus(包管理)、Npm、Docker、Kubernetes</p><h3 id="基础设施" tabindex="-1"><a class="header-anchor" href="#基础设施"><span>基础设施</span></a></h3><p>私有云、公有云(阿里云、腾讯云)、容器(docker、kubernetes)、虚拟机(vm)</p><p>参考自下图</p><p><img src="'+s+'" alt="73c1f13202d127de8ac7c544b112111"></p><h2 id="组件选型" tabindex="-1"><a class="header-anchor" href="#组件选型"><span>组件选型</span></a></h2><p>.NET Core+Swagger+Consul+Polly+Ocelot+IdentityServer4+Exceptionless+Apollo+SkyWalking</p><h3 id="网关" tabindex="-1"><a class="header-anchor" href="#网关"><span>网关</span></a></h3><p>API网关是微服务架构中的唯一入口，它提供一个单独且统一的API入口用于访问内部一个或多个API。它可以具有身份验证，监控，负载均衡，缓存，限流，请求分片与管理，静态响应处理等。</p><p>常用组件：Ocelot、kong、zuul、Envoy。</p><p>选型方案一： Kong和KongA作为我们的API网关，Kong是一个在Nginx运行的Lua应用程序，由lua-nginx-module实现。Kong和OpenResty一起打包发行，其中已经包含了lua-nginx-module。基本功能有路由、负载均衡、基本认证、限流、跨域、日志等功能，其他功能例如jwt认证可以通过插件进行扩展。 选择kong的理由：kong比Ocelot性能好，并且kong很多功能可以通过插件式按需使用与开发</p><h3 id="服务注册发现" tabindex="-1"><a class="header-anchor" href="#服务注册发现"><span>服务注册发现</span></a></h3><p>免去维护多个服务的配置信息(比如a服务被n个服务依赖，那么如果a服务地址一变动，那么n个服务都需要跟着改动)，可以直接通过服务名获取服务信息然后调用。 大致流程</p><ul><li><p>服务B启动后向服务注册发现服务注册自己的信息</p></li><li><p>服务A从注册中心服务获取服务B的信息</p></li><li><p>服务A调用服务B</p></li></ul><p>常用组件：Consul、Eureka、Nacos</p><p>选型方案一： 选用Consul+Consul Tamplate+nginx，Consul是基于GO语言开发的开源工具，主要面向分布式，服务化的系统提供服务注册、服务发现和配置管理的功能。 Consul的核心功能包括：服务注册/发现、健康检查、Key/Value存储、多数据中心和分布式一致性保证等特性。 Consul作为服务注册中心的存在，但是我们服务发现只能拿到IP列表，我们使用RPC调用时还是得做负载均衡算法，于是使用了Consul Tamplate把服务列表同步到nginx的配置，那么RPC框架就无需集成负载均衡算法经过nginx路由</p><h3 id="服务通信" tabindex="-1"><a class="header-anchor" href="#服务通信"><span>服务通信</span></a></h3><p>RPC框架主要三大核心，序列化、通信细节隐藏、代理。协议支持分TCP和HTTP，当然还有两者兼容+集成MQ的。</p><p>选型方案一 选择了WebApiClient做客户端，服务端仍是.Net Core WebAPI，主要考虑到WebAPIClient的轻量、易用，而且和Skywalking、Consul集成方便</p><h3 id="配置中心" tabindex="-1"><a class="header-anchor" href="#配置中心"><span>配置中心</span></a></h3><p>配置管理系统：为了解决微服务环境中配置文件繁杂，而且不同环境的不同配置修改相对频繁，每次发布都需要修改对应的配置，因此需要做统一的配置中心，能够做到自动更新配置文件信息。</p><h4 id="常用组件" tabindex="-1"><a class="header-anchor" href="#常用组件"><span>常用组件</span></a></h4><ul><li>Apollo</li><li>Zookeeper</li><li>AgileConfig</li><li>Nacos</li></ul><h3 id="分布式日志" tabindex="-1"><a class="header-anchor" href="#分布式日志"><span>分布式日志</span></a></h3><p>一般我们需要进行日志分析场景：直接在日志文件中就可以获得自己想要的信息。但在规模较大的场景中，此方法效率低下，面临问题包括日志量太大如何归档、文本搜索太慢怎么办、如何多维度查询。需要集中化的日志管理，所有服务器上的日志收集汇总。常见解决思路是建立集中式日志收集系统，将所有节点上的日志统一收集，管理，访问。 一般大型系统是一个分布式部署的架构，不同的服务模块部署在不同的服务器上，问题出现时，大部分情况需要根据问题暴露的关键信息，定位到具体的服务器和服务模块，构建一套集中式日志系统，可以提高定位问题的效率。 一个完整的集中式日志系统，需要包含以下几个主要特点：</p><ul><li>收集－能够采集多种来源的日志数据</li><li>传输－能够稳定的把日志数据传输到中央系统</li><li>存储－如何存储日志数据</li><li>分析－可以支持 UI 分析</li><li>警告－能够提供错误报告，监控机制</li></ul><p>日志收集的流程</p><ul><li>日志选择：确定哪些日志类型需要进行收集分析，比如调试，网络等等类型。</li><li>日志采集：使用哪种日志组件来作为采集，net中常用有nlog和log4net</li><li>日志缓存：使用kafka或者redios来缓冲日志手机的大量请求</li><li>日志筛选：筛选(过滤)哪些日志类型将要被存储，提前埋点</li><li>日志存储：日志的统一存储，例如es(Elasticsearch)</li><li>日志检索：日志的UI展现，例如ExceptionLess</li></ul><h4 id="常用组件-1" tabindex="-1"><a class="header-anchor" href="#常用组件-1"><span>常用组件</span></a></h4><p>ELK(ElasticSearch, Logstash, Kibana)   <a href="https://blog.csdn.net/e_wsq/article/details/81303713" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/e_wsq/article/details/81303713</a> EFK(ElasticSearch, Filebeat, Kibana)  <a href="https://blog.csdn.net/HuaZi_Myth/article/details/102770893" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/HuaZi_Myth/article/details/102770893</a> Exceptionless  <a href="https://www.cnblogs.com/Leo_wl/p/11068336.html?utm_medium=referral&amp;utm_source=itdadao" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/Leo_wl/p/11068336.html?utm_medium=referral&amp;utm_source=itdadao</a></p><h3 id="分布式追踪" tabindex="-1"><a class="header-anchor" href="#分布式追踪"><span>分布式追踪</span></a></h3><p>基本上都分三大块，UI、收集器、代理（探针），原理大概是把涉及的服务链路的RequestID串起来。</p><h4 id="产生场景" tabindex="-1"><a class="header-anchor" href="#产生场景"><span>产生场景</span></a></h4><p>一个业务流可能会经过多个微服务的处理和传递，这样子会面临以下问题 1.分散在各个服务器上的日志如何处理 2.业务流出现了错误和异常，如何定位是哪个点出现的问题？ 3.如何快速定位问题？ 4.如何跟踪业务流的处理顺序和结果？</p><h4 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h4><ul><li>分布式跟踪信息传递</li><li>分布式事务监控</li><li>服务依赖性分析</li><li>展示跨进程调用链</li><li>定位问题</li><li>性能优化</li></ul><h4 id="常用组件-2" tabindex="-1"><a class="header-anchor" href="#常用组件-2"><span>常用组件</span></a></h4><ul><li>Skywalking(对于.Net技术栈无侵入)</li><li>Zipkin</li><li>鹰眼</li><li>Jaeger</li><li>Datadog</li></ul><p>选型方案一 选择了SkyWalking作为了项目的分布式链路跟踪系统，原因很简单：易用，无侵入，集成良好。</p><h3 id="分布式事务" tabindex="-1"><a class="header-anchor" href="#分布式事务"><span>分布式事务</span></a></h3><p>分为：强一致性和最终一致性</p><table><thead><tr><th>分类</th><th>理论</th><th>案例</th><th>中间件</th></tr></thead><tbody><tr><td>强一致性</td><td>ACID</td><td>二阶段提交</td><td>msdtc</td></tr><tr><td>最终一致性</td><td>BASE</td><td>本地消息表</td><td>CAP</td></tr></tbody></table><p>选型方案一 本地消息表是eBay在N年前提出的方案，而CAP以该思想实现的一门框架，原理大概是，本地业务表与消息凭据表作为一个事务持久化，通过各种补偿手段保证MQ消息的可靠性，包括MQ正常发布与消费。</p><h3 id="系统监控" tabindex="-1"><a class="header-anchor" href="#系统监控"><span>系统监控</span></a></h3><p>因为微服务出现问题无法快速定位问题，这个时候就需要监控系统柜。 一般分为以下几个维度的监控： 硬件资源类监控，监控cpu、内存、存储等指标 应用类监控，围绕对应用、服务、容器的健康监控，对接口的调用链、性能进行调控 运营类监控，比如监控每天流水、注册人数等</p><h4 id="常用组件-3" tabindex="-1"><a class="header-anchor" href="#常用组件-3"><span>常用组件</span></a></h4><ul><li>Prometheus</li><li>HttpReports</li><li>Zabbix</li></ul><h3 id="文件系统" tabindex="-1"><a class="header-anchor" href="#文件系统"><span>文件系统</span></a></h3><p>统一一个服务作为文件存储服务。 常用组件：TFS</p><h3 id="重试策略" tabindex="-1"><a class="header-anchor" href="#重试策略"><span>重试策略</span></a></h3><p>对一个方法或者一个请求进行多次重试 常用组件：Polly</p><h3 id="认证鉴权" tabindex="-1"><a class="header-anchor" href="#认证鉴权"><span>认证鉴权</span></a></h3><p>常用组件：ids</p><h3 id="部署方案" tabindex="-1"><a class="header-anchor" href="#部署方案"><span>部署方案</span></a></h3><p>通过容器部署 常用组件：docker、k8s、k3s</p><h2 id="资料" tabindex="-1"><a class="header-anchor" href="#资料"><span>资料</span></a></h2><p>https://www.cnblogs.com/wyt007/p/10631109.html | 基于.net core微服务（Consul、Ocelot、Docker、App.Metrics+InfluxDB+Grafana、Exceptionless、数据一致性、Jenkins） - 一个大西瓜咚咚咚 - 博客园</p><p>https://www.cnblogs.com/lifeng618/p/14120044.html | 2020年总结-用学习过的技术搭建一个简单的微服务框架 + 源码 - 往事随灬锋 - 博客园</p><h2 id="参考文档" tabindex="-1"><a class="header-anchor" href="#参考文档"><span>参考文档</span></a></h2><p>.Net Core with 微服务架构图 <a href="https://mp.weixin.qq.com/s/Mw6_bfzKcLVLtf6CGIvJYg" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/Mw6_bfzKcLVLtf6CGIvJYg</a><a href="https://mp.weixin.qq.com/s/oBZy6e4C9xU67Qa38hxOfA" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/oBZy6e4C9xU67Qa38hxOfA</a> | .Net微服务实战之可观测性 技术选型：<a href="https://mp.weixin.qq.com/s/-yQB9ZwewnTbwwVRaOXFVA" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/-yQB9ZwewnTbwwVRaOXFVA</a></p>',77)]))}const d=a(r,[["render",p],["__file","jiagoutu.html.vue"]]),g=JSON.parse('{"path":"/middleware/smallService/jiagoutu.html","title":"架构图","lang":"zh-CN","frontmatter":{"title":"架构图","lang":"zh-CN","date":"2023-06-24T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["middleware"],"tag":["无"],"filename":"jiagoutu","slug":"gq6ptl","docsId":"31211537","description":"架构图 这个图我感觉挺对，聚合服务层根据情况使用 架构示例 前端 ES6、Vue全家桶、Element UI、Sass、axios、dayjs、echarts 后端 .Net Core、EFCore、JWT、RabbitMq、Swagger、WebSocket 数据库 MySQL、postgres、sqlserver、oracle、达梦数据库、人大金仓...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/middleware/smallService/jiagoutu.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"架构图"}],["meta",{"property":"og:description","content":"架构图 这个图我感觉挺对，聚合服务层根据情况使用 架构示例 前端 ES6、Vue全家桶、Element UI、Sass、axios、dayjs、echarts 后端 .Net Core、EFCore、JWT、RabbitMq、Swagger、WebSocket 数据库 MySQL、postgres、sqlserver、oracle、达梦数据库、人大金仓..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://azrng.gitee.io/kbms/kbms/common/1624497455143-104691ec-981b-435c-b6db-3389013aed54.webp"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-18T07:15:56.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-06-24T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-18T07:15:56.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"架构图\\",\\"image\\":[\\"https://azrng.gitee.io/kbms/kbms/common/1624497455143-104691ec-981b-435c-b6db-3389013aed54.webp\\",\\"https://azrng.gitee.io/kbms/kbms/softwareDesign/73c1f13202d127de8ac7c544b112111.jpg\\"],\\"datePublished\\":\\"2023-06-24T00:00:00.000Z\\",\\"dateModified\\":\\"2024-05-18T07:15:56.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"架构图","slug":"架构图","link":"#架构图","children":[]},{"level":2,"title":"架构示例","slug":"架构示例","link":"#架构示例","children":[{"level":3,"title":"前端","slug":"前端","link":"#前端","children":[]},{"level":3,"title":"后端","slug":"后端","link":"#后端","children":[]},{"level":3,"title":"数据库","slug":"数据库","link":"#数据库","children":[]},{"level":3,"title":"数据缓存","slug":"数据缓存","link":"#数据缓存","children":[]},{"level":3,"title":"文件存储","slug":"文件存储","link":"#文件存储","children":[]},{"level":3,"title":"中间件","slug":"中间件","link":"#中间件","children":[]},{"level":3,"title":"Devops","slug":"devops","link":"#devops","children":[]},{"level":3,"title":"基础设施","slug":"基础设施","link":"#基础设施","children":[]}]},{"level":2,"title":"组件选型","slug":"组件选型","link":"#组件选型","children":[{"level":3,"title":"网关","slug":"网关","link":"#网关","children":[]},{"level":3,"title":"服务注册发现","slug":"服务注册发现","link":"#服务注册发现","children":[]},{"level":3,"title":"服务通信","slug":"服务通信","link":"#服务通信","children":[]},{"level":3,"title":"配置中心","slug":"配置中心","link":"#配置中心","children":[{"level":4,"title":"常用组件","slug":"常用组件","link":"#常用组件","children":[]}]},{"level":3,"title":"分布式日志","slug":"分布式日志","link":"#分布式日志","children":[{"level":4,"title":"常用组件","slug":"常用组件-1","link":"#常用组件-1","children":[]}]},{"level":3,"title":"分布式追踪","slug":"分布式追踪","link":"#分布式追踪","children":[{"level":4,"title":"产生场景","slug":"产生场景","link":"#产生场景","children":[]},{"level":4,"title":"使用场景","slug":"使用场景","link":"#使用场景","children":[]},{"level":4,"title":"常用组件","slug":"常用组件-2","link":"#常用组件-2","children":[]}]},{"level":3,"title":"分布式事务","slug":"分布式事务","link":"#分布式事务","children":[]},{"level":3,"title":"系统监控","slug":"系统监控","link":"#系统监控","children":[{"level":4,"title":"常用组件","slug":"常用组件-3","link":"#常用组件-3","children":[]}]},{"level":3,"title":"文件系统","slug":"文件系统","link":"#文件系统","children":[]},{"level":3,"title":"重试策略","slug":"重试策略","link":"#重试策略","children":[]},{"level":3,"title":"认证鉴权","slug":"认证鉴权","link":"#认证鉴权","children":[]},{"level":3,"title":"部署方案","slug":"部署方案","link":"#部署方案","children":[]}]},{"level":2,"title":"资料","slug":"资料","link":"#资料","children":[]},{"level":2,"title":"参考文档","slug":"参考文档","link":"#参考文档","children":[]}],"git":{"createdTime":1697724028000,"updatedTime":1716016556000,"contributors":[{"name":"azrng","username":"azrng","email":"itzhangyunpeng@163.com","commits":4}]},"readingTime":{"minutes":6.92,"words":2076},"filePathRelative":"middleware/smallService/jiagoutu.md","localizedDate":"2023年6月24日","excerpt":"<h2>架构图</h2>\\n<p><img src=\\"/common/1624497455143-104691ec-981b-435c-b6db-3389013aed54.webp\\" alt=\\"\\"></p>\\n<p>这个图我感觉挺对，聚合服务层根据情况使用</p>\\n<h2>架构示例</h2>\\n<h3>前端</h3>\\n<p>ES6、Vue全家桶、Element UI、Sass、axios、dayjs、echarts</p>\\n<h3>后端</h3>\\n<p>.Net Core、EFCore、JWT、RabbitMq、Swagger、WebSocket</p>\\n<h3>数据库</h3>\\n<p>MySQL、postgres、sqlserver、oracle、达梦数据库、人大金仓</p>","autoDesc":true}');export{d as comp,g as data};
