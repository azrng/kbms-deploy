import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as t,d as n}from"./app-w1jKZwvY.js";const e={},a=n(`<h2 id="组件" tabindex="-1"><a class="header-anchor" href="#组件"><span>组件</span></a></h2><h3 id="identitymodel" tabindex="-1"><a class="header-anchor" href="#identitymodel"><span>IdentityModel</span></a></h3><p>OpenID Connect &amp; OAuth 2.0 client library IdentityModel是一个基于Claim的Identity库，提供了一组类来标识用户的身份，以及对这些东西的抽象。</p><blockquote><p>历史介绍：最初，IdentityModel 是属于 WIF(Windows Identity Foundation) 的一部分，WIF 是微软2004年给 .NET 平台搞的一套身份验证框架（包含Claims，Configuration，Metadata，Policy，Servicesd等等），微软想把这个东西作为 .NET 标准框架的一部分，所以它的命名空间是 System.IdentityModel， 了解这个东西的人不是很多，不过不知道也没关系，反正这玩意也已经被淘汰了。 在 .NET Core 中， WIF 这些套件只有 System.IdentityModel.Tokens.Jwt 被保留了下来，其他全被扔掉了，为什么呢？ 原因是只有 JWT 这部分东西有用，其他的部分更多的是为以前的 Web Servics, WCF 那套分布式东西设计的，那套分布式的东西淘汰了，自然也不必要保留了。</p></blockquote><p>在没有 .NET Core 的时候，我们想实现一套标准的单点登录(SSO)系统就可以利用 System.IdentityModel 因为它已经为我们做了大量工作，并且是标准化的。在 .NET Core 中也需要一些标准的抽象东西那怎么办呢？微软弄了一套新的 IdentityModel 的库，命名空间为 Microsoft.IdentityModel。很多人甚至都找不到它的源码在哪里，我一开始也没找到，最后发现在 <a href="https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet" target="_blank" rel="noopener noreferrer">https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet</a> 这个仓库里面。 来源：<a href="https://www.cnblogs.com/savorboard/p/authentication.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/savorboard/p/authentication.html</a></p><h3 id="system-identitymodel-tokens-jwt" tabindex="-1"><a class="header-anchor" href="#system-identitymodel-tokens-jwt"><span>System.IdentityModel.Tokens.Jwt</span></a></h3><p>包括支持创建、序列化和验证JSON Web token的类型。</p><h3 id="microsoft-identitymodel-protocols-openidconnect" tabindex="-1"><a class="header-anchor" href="#microsoft-identitymodel-protocols-openidconnect"><span>Microsoft.IdentityModel.Protocols.OpenIdConnect</span></a></h3><p>依赖组件：System.IdentityModel.Tokens.Jwt、Microsoft.IdentityModel.Protocols 为OpenIdConnect 协议提供支持的类型。</p><h3 id="microsoft-aspnetcore-authentication" tabindex="-1"><a class="header-anchor" href="#microsoft-aspnetcore-authentication"><span>Microsoft.AspNetCore.Authentication</span></a></h3><blockquote><p>默认包含在.NetCore框架里面</p></blockquote><p>Authentication 在 ASP.NET Core 中，对于 Authentication（认证） 的抽象实现，此中间件用来处理或者提供管道中的 HttpContext 里面的 AuthenticationManager 相关功能抽象实现。HttpContext 中的 User 相关信息同样在此中间件中被初始化。 对于开发人员只需要了解此中间件中的这几个对象即可：</p><ul><li>AuthenticationOptions 对象主要是用来提供认证相关中间件配置项，后面的 OpenIdConnect，OAuth，Cookie 等均是继承于此。</li><li>AuthenticationHandler 对请求流程中（Pre-Request）中相关认证部分提供的一个抽象处理类，同样后面的其他几个中间件均是继承于此。</li></ul><p>在 AuthenticationHandler 中, 有几个比较重要的方法:</p><ul><li>HandleAuthenticateAsync ：处理认证流程中的一个核心方法，这个方法返回 AuthenticateResult来标记是否认证成功以及返回认证过后的票据（AuthenticationTicket）。</li><li>HandleUnauthorizedAsync：可以重写此方法用来处理相应401未授权等问题，修改头，或者跳转等。</li><li>HandleSignInAsync：对齐 HttpContext AuthenticationManager 中的 SignInAsync</li><li>HandleSignOutAsync：对齐 HttpContext AuthenticationManager 中的 SignOutAsync</li><li>HandleForbiddenAsync：对齐 HttpContext AuthenticationManager 中的 ForbidAsync，用来处理禁用等结果</li></ul><p>以上关于 AuthenticationHandler 我列出来的这些方法都是非常容易理解的，我们在继承Authentication实现我们自己的一个中间件的时候只需要重写上面的一个或者多个方法即可。还有一个 RemoteAuthenticationHandler 它也是继承AuthenticationHandler，主要是针对于远程调用提供出来的一个抽象，什么意思呢？因为很多时候我们的认证是基于OAuth的，也就是说用户的状态信息是存储到Http Header 里面每次进行往来的，而不是cookie等，所以在这个类里面了一个HandleRemoteAuthenticateAsync的函数。</p><h3 id="microsoft-aspnetcore-authentication-cookies" tabindex="-1"><a class="header-anchor" href="#microsoft-aspnetcore-authentication-cookies"><span>Microsoft.AspNetCore.Authentication.Cookies</span></a></h3><p>Cookies 认证是 ASP.NET Core Identity 默认使用的身份认证方式，那么这个中间件主要是干什么的呢 我们知道，在 ASP.NET Core 中已经没有了 Forms 认证，取而代之的是一个叫 “个人用户账户” 的一个东西，如下图，你在新建一个ASP.ENT Core Web 应用程序的时候就会发现它，它实际上就是 Identity。那么Forms认证去哪里了呢？对，就是换了个名字叫 Identity。 在此中间件中，主要是针对于Forms认证的一个实现，也就是说它通过Cookie把用户的个人身份信息通过加密的票据存储的Cookie中去，如果看过我之前Identity系列文章的话，那么应该知道用户的个人身份信息就是 ClaimsIdentity 相关的东西。 这个中间件引用了Authentication，CookieAuthenticationHandler 类继承了 AuthenticationHandler 并重写了 HandleAuthenticateAsync,HandleSignInAsync,HandleSignOutAsync，HandleForbiddenAsync,HandleUnauthorizedAsync 等方法，就是上一节中列出来的几个方法。我们主要看一下核心方法 HandleAuthenticateAsync 在 Cookie 中间件怎么实现的：</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">protected</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> override</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> async</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Task</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">AuthenticateResult</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">HandleAuthenticateAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    //读取并解密从浏览器获取的Cookie</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> EnsureCookieTicket</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Succeeded</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> result</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">     </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 使用上一步结果构造 CookieValidatePrincipalContext 对象</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 这个对象是一个包装类，里面装着 ClaimsPrincipal、AuthenticationProperties</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> context</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> CookieValidatePrincipalContext</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">Context</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Ticket</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">Options</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 默认是空的实现，可以重写来验证 CookieValidatePrincipalContext 是否有异常</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">    await</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> Options</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Events</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">ValidatePrincipal</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Principal</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> AuthenticateResult</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Fail</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;No principal.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 表示是否需要刷新Cookie</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">ShouldRenew</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">        RequestRefresh</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Ticket</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> AuthenticateResult</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Success</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> AuthenticationTicket</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Principal</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Properties</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Options</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">AuthenticationScheme</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结一下就是解密Http请求中的Cookie信息，然后验证Cookie是否合法，然后提取Cookie中的信息返回结果。 还有一个方法就是 HandleSignInAsync ，根据名字可以看出主要是处理登入相关操作的，在这个方法里面主要是根据Claims信息生成加入过后的票据，同时会向票据中写入过期时间，是否持久化等信息。是否持久化的意思就是用户在登陆界面是否勾选了 “记住我” 这个操作。</p><h3 id="microsoft-aspnetcore-authentication-oauth" tabindex="-1"><a class="header-anchor" href="#microsoft-aspnetcore-authentication-oauth"><span>Microsoft.AspNetCore.Authentication.OAuth</span></a></h3><p>OAuth 是针对于 OAuth 2.0 标准实现的一个客户端程序，记住是客户端，它不具备发放Token或者 Client_id ,Code 等的功能，它的作用是帮你简化对OAuth2.0服务端程序的调用。它对应 OAuth 2.0 标准中的 “获取Access_Token” 这一步骤，如果对腾讯开放平台QQ授权比较了解的话，就是对应 “使用Authorization_Code获取Access_Token” 这一步骤。</p><h3 id="microsoft-aspnetcore-authentication-openidconnect" tabindex="-1"><a class="header-anchor" href="#microsoft-aspnetcore-authentication-openidconnect"><span>Microsoft.AspNetCore.Authentication.OpenIdConnect</span></a></h3><p>依赖组件：Microsoft.IdentityModel.Protocols.OpenIdConnect 获取 OpenId 是OAuth 授权中的一个步骤，OpenId 它是具体的一个Token Key，不要把他理解成一种授权方式或者和OAuth不同的另外一种东西，他们是一体的。 代码上就不详细说了，和上面的都差不多。主要说一下它们之间的区别或者叫联系。 OAuth 它主要是针对于授权（Authorization），而OpenID主要是针对于认证（Authentication），他们之间是互补的。 那什么叫授权呢？比如小明是使用我们网站的一个用户，他现在要在另外一个网站使用在我们网站注册的账号，那授权就是代表小明在另外一个网站能够做什么东西？比如能够查看资料，头像，相册等等，授权会给用户发放一个叫 Access_Token 的东西。 而认证关注的这个用户是谁，它是用来证明用户东西。比如小明要访问它的相册，那我们网站就需要小明提供一个叫OpenId的一个东西，我们只认这个OpenId。那小明从哪里得到它的这个OpenId呢，对，就是使用上一步的Access_Token 来换取这 个 OpenId ，以后访问的时候不认 Access_Token ，只认识OpenId这个东西。 一般情况下，OpenId 是需要客户端进行持久化的，那么对应在 ASP.NET Core Identity 中，就是存储在 UsersLogin 表里面的 ProviderKey 字段。</p><h3 id="microsoft-aspnetcore-authentication-jwtbearer" tabindex="-1"><a class="header-anchor" href="#microsoft-aspnetcore-authentication-jwtbearer"><span>Microsoft.AspNetCore.Authentication.JwtBearer</span></a></h3><p>JwtBearer 这个中间件是依赖于上一步的 OpenIdConnect 中间件的，看到了吧，其实这几个中间件是环环嵌套的。 可能很多同学听说过 Jwt，但是大多数人都有一个误区，认为JWT是一种认证方式，经常在QQ群里面听过 前面一个同学在问 实际开发中前后端分离的时候安全怎么做的？，下面一个人回答使用JWT。 其实JWT 它不是一种认证方式，也不是一种认证的技术，它是一个规范，一个标准。 Jwt（Json Web Token）的官网是 https://jwt.io，下面是对JWT的一个说明</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> Web</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> Tokens</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> are</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> an</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> open</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;">industry</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> standard</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> RFC</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> 7519 </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;">method</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> for</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> representing</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> claims</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> securely</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> between</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> two</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> parties</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;">JSON</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> Web</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> Tokens</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">（</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;">JWT</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">） </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;">是一个开放的行业标准</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">（ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;">RFC</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> 7519），</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;">用于在双方之间传递安全的Claims</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>JWT 在身份认证中的应用场景</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">在身份认证场景下</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">，</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">一旦用户完成了登陆</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">，</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">在接下来的每个请求中包含JWT</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">，</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">可以用来验证用户身份以及对路由</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">，</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">服务和资源的访问权限进行验证</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">。</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">由于它的开销非常小</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">，</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">可以轻松的在不同域名的系统中传递</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">，</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">所有目前在单点登录</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">（</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">SSO</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">）</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">中比较广泛的使用了该技术</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>好了，不过多的说了。我们还是接着看一下 JwtBearer 中间件，同样它重写了 HandleAuthenticateAsync 方法。 大致步骤如下：</p><ol><li>读取 Http Request Header 中的 Authorization 信息</li><li>读取 Authorization 值里面的 Bearer 信息</li><li>验证 Bearer 是否合法，会得到一个 ClaimsPrincipal</li><li>使用 ClaimsPrincipal 构建一个 Ticket（票据）</li><li>调用 Options.Events.TokenValidated(context)，用户可以重写此方法验证Token合法性</li><li>返回验证成功</li></ol><h3 id="microsoft-identitymodel-tokens" tabindex="-1"><a class="header-anchor" href="#microsoft-identitymodel-tokens"><span>Microsoft.IdentityModel.Tokens</span></a></h3><h2 id="其他知识点" tabindex="-1"><a class="header-anchor" href="#其他知识点"><span>其他知识点</span></a></h2><p>这几个中间件对会有对应的 Options 配置项，在这些配置项中，都会有 AuthenticationScheme, AutomaticAuthenticate, AutomaticChallenge 这几个属性，那这几个东西都是干嘛的呢？</p><h3 id="authenticationscheme" tabindex="-1"><a class="header-anchor" href="#authenticationscheme"><span>AuthenticationScheme</span></a></h3><p>在 MVC 程序中一般通过在 Controller 或者 Action 上 打标记（Attribute）的方式进行授权，最典型的就是新建一个项目的时候里面的AccountController。</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Authorize</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> AccountController</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Controller</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Authorize 这个 Attribute 中，有一个属性叫做 ActiveAuthenticationSchemes 的东西，那么这个东西是干什么用的呢？ ActiveAuthenticationSchemes 就是对应着中间件Options里面配置的 AuthenticationScheme ，如果你不指定的话，在使用多个身份验证组件的时候会有问题，会有什么问题呢？</p><h3 id="automaticauthenticate" tabindex="-1"><a class="header-anchor" href="#automaticauthenticate"><span>AutomaticAuthenticate</span></a></h3><p>AutomaticAuthenticate 很简单，是一个bool类型的字段，用来配置是否处理 AuthenticationHandler 是否处理请求。或者你可以理解为中间件是不是自动的处理认证相关的业务。</p><h3 id="automaticchallenge" tabindex="-1"><a class="header-anchor" href="#automaticchallenge"><span>AutomaticChallenge</span></a></h3><p>这个<strong>重要</strong>哦！当我们使用多个身份验证中间件的时候，那么就要用到这个配置项了，该配置项是用来设置哪个中间件会是身份验证流程中的默认中间件，当代码运行到 Controller 或者 Action 上的 [Authorize] 这个标记的时候，就会触发身份验证流程。默认情况下MVC的Filter会自动的触发[Authorize]，当然也有一种手动触发Authorize的办法就是使用HttpContext.Authentication.ChallengeAsync()。 实际上，在验证中间件的管道流程中，应该只有一个组件被设定为 AutomaticChallenge = true，但其实大多数的中间件这个参数默认都是 true ，这些中间件包括（Identity, Cookie, OAuth, OpenId, IISIntegration, WebListener）等， 这就导致了在整个验证流程中会触发多个中间件对其进行相应，这种冲突大部分不是用户期望的结果。 不幸的是，目前框架对于这种情况并没有一个健壮的机制，如果开发人员对于这种机制不是很清楚的话，可能会造成很大的困扰。 幸运的是，ASP.NET Core 团队已经意识到了这个问题，他们将在 NET Standard 2.0 中对此重新进行设计，比如手动触发的时候应该怎么处理，有多个的时候怎么处理，以及会添加一些语法糖。 目前情况下，当有多个验证中间件的时候，应该怎么处理呢？比如同时使用 Identity 和 JwtBearer。正确的做法是应该禁用掉除 Identity 以外的其他中间件的 AutomaticChallenge，然后指定调用的AuthenticationScheme。也就是说在Controller或者Action显式指定 [Authorize(ActiveAuthenticationSchemes = JwtBearerDefaults.AuthenticationScheme)] ，或者是可以指定一个策略来简化授权调用 [Authorize(&quot;ApiPolicy&quot;)]</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">services</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">AddAuthorization</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">options</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> =&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    options</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">AddPolicy</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;ApiPolicy&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">policy</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> =&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        policy</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">AddAuthenticationSchemes</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">JwtBearerDefaults</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">AuthenticationScheme</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        policy</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">RequireAuthenticatedUser</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而默认不带参数的 [Authorize] 可以指定AuthorizationPolicie：</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">services</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">AddAuthorization</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">options</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> =&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    options</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">DefaultPolicy</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> AuthorizationPolicyBuilder</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Identity.Application&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">RequireAuthenticatedUser</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Build</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，手动调用 HttpContext.Authentication.ChallengeAsync() 不受 AuthorizationPolicie 影响。</p><h2 id="资料" tabindex="-1"><a class="header-anchor" href="#资料"><span>资料</span></a></h2><p><a href="https://mp.weixin.qq.com/s/XiBZ5JHyWO1cbrq-Fud-BQ" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/XiBZ5JHyWO1cbrq-Fud-BQ</a> | ASP.NET Core 中的那些认证中间件及一些重要知识点</p>`,48),h=[a];function l(p,k){return t(),s("div",null,h)}const d=i(e,[["render",l],["__file","changyongzujian.html.vue"]]),c=JSON.parse('{"path":"/dotnet/anquanhebiaoshi/shenfenrenzhengheshouquan/changyongzujian.html","title":"常用组件","lang":"zh-CN","frontmatter":{"title":"常用组件","lang":"zh-CN","date":"2022-04-27T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["dotNET"],"tag":["无"],"filename":"changyongzujian","slug":"ghrbi7","docsId":"69241791","description":"组件 IdentityModel OpenID Connect & OAuth 2.0 client library IdentityModel是一个基于Claim的Identity库，提供了一组类来标识用户的身份，以及对这些东西的抽象。 历史介绍：最初，IdentityModel 是属于 WIF(Windows Identity Foundation...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dotnet/anquanhebiaoshi/shenfenrenzhengheshouquan/changyongzujian.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"常用组件"}],["meta",{"property":"og:description","content":"组件 IdentityModel OpenID Connect & OAuth 2.0 client library IdentityModel是一个基于Claim的Identity库，提供了一组类来标识用户的身份，以及对这些东西的抽象。 历史介绍：最初，IdentityModel 是属于 WIF(Windows Identity Foundation..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-22T08:11:43.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2022-04-27T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-10-22T08:11:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"常用组件\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-04-27T00:00:00.000Z\\",\\"dateModified\\":\\"2023-10-22T08:11:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"组件","slug":"组件","link":"#组件","children":[{"level":3,"title":"IdentityModel","slug":"identitymodel","link":"#identitymodel","children":[]},{"level":3,"title":"System.IdentityModel.Tokens.Jwt","slug":"system-identitymodel-tokens-jwt","link":"#system-identitymodel-tokens-jwt","children":[]},{"level":3,"title":"Microsoft.IdentityModel.Protocols.OpenIdConnect","slug":"microsoft-identitymodel-protocols-openidconnect","link":"#microsoft-identitymodel-protocols-openidconnect","children":[]},{"level":3,"title":"Microsoft.AspNetCore.Authentication","slug":"microsoft-aspnetcore-authentication","link":"#microsoft-aspnetcore-authentication","children":[]},{"level":3,"title":"Microsoft.AspNetCore.Authentication.Cookies","slug":"microsoft-aspnetcore-authentication-cookies","link":"#microsoft-aspnetcore-authentication-cookies","children":[]},{"level":3,"title":"Microsoft.AspNetCore.Authentication.OAuth","slug":"microsoft-aspnetcore-authentication-oauth","link":"#microsoft-aspnetcore-authentication-oauth","children":[]},{"level":3,"title":"Microsoft.AspNetCore.Authentication.OpenIdConnect","slug":"microsoft-aspnetcore-authentication-openidconnect","link":"#microsoft-aspnetcore-authentication-openidconnect","children":[]},{"level":3,"title":"Microsoft.AspNetCore.Authentication.JwtBearer","slug":"microsoft-aspnetcore-authentication-jwtbearer","link":"#microsoft-aspnetcore-authentication-jwtbearer","children":[]},{"level":3,"title":"Microsoft.IdentityModel.Tokens","slug":"microsoft-identitymodel-tokens","link":"#microsoft-identitymodel-tokens","children":[]}]},{"level":2,"title":"其他知识点","slug":"其他知识点","link":"#其他知识点","children":[{"level":3,"title":"AuthenticationScheme","slug":"authenticationscheme","link":"#authenticationscheme","children":[]},{"level":3,"title":"AutomaticAuthenticate","slug":"automaticauthenticate","link":"#automaticauthenticate","children":[]},{"level":3,"title":"AutomaticChallenge","slug":"automaticchallenge","link":"#automaticchallenge","children":[]}]},{"level":2,"title":"资料","slug":"资料","link":"#资料","children":[]}],"git":{"createdTime":1697962303000,"updatedTime":1697962303000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":1}]},"readingTime":{"minutes":10.42,"words":3125},"filePathRelative":"dotnet/anquanhebiaoshi/shenfenrenzhengheshouquan/changyongzujian.md","localizedDate":"2022年4月27日","excerpt":"<h2>组件</h2>\\n<h3>IdentityModel</h3>\\n<p>OpenID Connect &amp; OAuth 2.0 client library\\nIdentityModel是一个基于Claim的Identity库，提供了一组类来标识用户的身份，以及对这些东西的抽象。</p>\\n<blockquote>\\n<p>历史介绍：最初，IdentityModel 是属于 WIF(Windows Identity Foundation) 的一部分，WIF 是微软2004年给 .NET 平台搞的一套身份验证框架（包含Claims，Configuration，Metadata，Policy，Servicesd等等），微软想把这个东西作为 .NET 标准框架的一部分，所以它的命名空间是 System.IdentityModel， 了解这个东西的人不是很多，不过不知道也没关系，反正这玩意也已经被淘汰了。\\n在 .NET Core 中， WIF 这些套件只有 System.IdentityModel.Tokens.Jwt 被保留了下来，其他全被扔掉了，为什么呢？\\n原因是只有 JWT 这部分东西有用，其他的部分更多的是为以前的 Web Servics, WCF 那套分布式东西设计的，那套分布式的东西淘汰了，自然也不必要保留了。</p>\\n</blockquote>","autoDesc":true}');export{d as comp,c as data};
