import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o as a,d as n}from"./app-DZ9bmjCp.js";const i={},o=n('<h2 id="目的" tabindex="-1"><a class="header-anchor" href="#目的"><span>目的</span></a></h2><p>利用解耦是保证代码不至于复杂到无法控制的有效手段。</p><p>代码高内聚低耦合，也就意味着：代码结构清洗、分层和模块化合理、依赖关系简单、模块或者类之间耦合小，那代码整体的质量就不会差。</p><h2 id="如何衡量" tabindex="-1"><a class="header-anchor" href="#如何衡量"><span>如何衡量</span></a></h2><p>如何判断系统是否需要解耦重构？ 比如看代码会不会牵一发而动全身。比如把模块和模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构，比如依赖关系复杂、混乱，那就说明可读性和可维护性不是太好，那我们就需要考虑是否可以通过解耦的方法，让依赖关系变得清洗、简单。</p><h2 id="如何解耦" tabindex="-1"><a class="header-anchor" href="#如何解耦"><span>如何解耦</span></a></h2><h3 id="封装和抽象" tabindex="-1"><a class="header-anchor" href="#封装和抽象"><span>封装和抽象</span></a></h3><p>封装和抽象可以有效隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口。</p><p>封装抽象函数，可以有效避免复杂性蔓延，将复杂性封装在局部代码中。</p><h3 id="中间层" tabindex="-1"><a class="header-anchor" href="#中间层"><span>中间层</span></a></h3><p>通过引入中间层能简化模块和类之间的依赖关系。比如三个类分别依赖其他的三个类，这个时候让引入中间层，然后三个模块只需要依赖一个中间层吗，让中间层去依赖其他另外的三个类。</p><h3 id="模块化" tabindex="-1"><a class="header-anchor" href="#模块化"><span>模块化</span></a></h3><p>将系统拆分为各个独立的模块，让不同的人负责不同的模块，这样子即时不了解全部细节的情况下，管理者也能协调各个模块。</p><p>合理划分模块能够有效解耦代码，提高代码的可读性和可维护性。</p>',14),r=[o];function l(p,h){return a(),t("div",null,r)}const d=e(i,[["render",l],["__file","jieou.html.vue"]]),g=JSON.parse('{"path":"/softwareDesign/highQualityCode/guifanyuchonggou/jieou.html","title":"解耦","lang":"zh-CN","frontmatter":{"title":"解耦","lang":"zh-CN","date":"2023-09-05T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["软件设计"],"tag":["无"],"filename":"jieou","slug":"xukpvk","docsId":"79657664","description":"目的 利用解耦是保证代码不至于复杂到无法控制的有效手段。 代码高内聚低耦合，也就意味着：代码结构清洗、分层和模块化合理、依赖关系简单、模块或者类之间耦合小，那代码整体的质量就不会差。 如何衡量 如何判断系统是否需要解耦重构？ 比如看代码会不会牵一发而动全身。比如把模块和模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构，...","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/softwareDesign/highQualityCode/guifanyuchonggou/jieou.html"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"解耦"}],["meta",{"property":"og:description","content":"目的 利用解耦是保证代码不至于复杂到无法控制的有效手段。 代码高内聚低耦合，也就意味着：代码结构清洗、分层和模块化合理、依赖关系简单、模块或者类之间耦合小，那代码整体的质量就不会差。 如何衡量 如何判断系统是否需要解耦重构？ 比如看代码会不会牵一发而动全身。比如把模块和模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-23T01:45:31.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-09-05T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-10-23T01:45:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"解耦\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-09-05T00:00:00.000Z\\",\\"dateModified\\":\\"2023-10-23T01:45:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"目的","slug":"目的","link":"#目的","children":[]},{"level":2,"title":"如何衡量","slug":"如何衡量","link":"#如何衡量","children":[]},{"level":2,"title":"如何解耦","slug":"如何解耦","link":"#如何解耦","children":[{"level":3,"title":"封装和抽象","slug":"封装和抽象","link":"#封装和抽象","children":[]},{"level":3,"title":"中间层","slug":"中间层","link":"#中间层","children":[]},{"level":3,"title":"模块化","slug":"模块化","link":"#模块化","children":[]}]}],"git":{"createdTime":1693926838000,"updatedTime":1698025531000,"contributors":[{"name":"zhangyunpeng","email":"zhang.yunpeng@synyi.com","commits":1}]},"readingTime":{"minutes":1.63,"words":488},"filePathRelative":"softwareDesign/highQualityCode/guifanyuchonggou/jieou.md","localizedDate":"2023年9月5日","excerpt":"<h2>目的</h2>\\n<p>利用解耦是保证代码不至于复杂到无法控制的有效手段。</p>\\n<p>代码高内聚低耦合，也就意味着：代码结构清洗、分层和模块化合理、依赖关系简单、模块或者类之间耦合小，那代码整体的质量就不会差。</p>\\n<h2>如何衡量</h2>\\n<p>如何判断系统是否需要解耦重构？\\n比如看代码会不会牵一发而动全身。比如把模块和模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构，比如依赖关系复杂、混乱，那就说明可读性和可维护性不是太好，那我们就需要考虑是否可以通过解耦的方法，让依赖关系变得清洗、简单。</p>\\n<h2>如何解耦</h2>\\n<h3>封装和抽象</h3>","autoDesc":true}');export{d as comp,g as data};
