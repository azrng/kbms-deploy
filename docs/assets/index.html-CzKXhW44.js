import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,o as a,d as n}from"./app-BuY9BHbl.js";const e="/kbms/common/1646058570865-e5afe134-558f-4e70-aee1-49276f97c1eb.png",l="/kbms/common/1646058609063-e0eec184-b082-43ae-af0f-179fa5885081.png",p={},t=n(`<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><p>内存是有效的，不可能无止境分配空间，因此就产生了GC的需求。</p><h2 id="gc" tabindex="-1"><a class="header-anchor" href="#gc"><span>Gc</span></a></h2><p>.NET GC (Garbage Collection) 是自动内存管理的一种方式，可以帮助开发者避免手动释放内存而导致的许多问题。在 .NET 环境下，GC 会定期扫描程序中的堆（heap）对象，标记出已经不再使用的对象并将其回收。</p><p>漫画解释GC原理：<a href="https://blog.kitlau.dev/posts/cartoon-dotnet-garbage-collection/" target="_blank" rel="noopener noreferrer">https://blog.kitlau.dev/posts/cartoon-dotnet-garbage-collection/</a></p><p>简述工作过程</p><ol><li>初始阶段：当应用程序启动时，CLR 会为该程序创建一个堆并分配一些初始内存。这个堆被称为“新生代”（Generation 0）。</li><li>新生代对象分配：当应用程序创建新的对象时，CLR 将它们分配到新生代中。</li><li>新生代垃圾回收：当新生代中的对象数量达到一定阈值时，CLR 会触发新生代 GC。在这个阶段，CLR 将扫描新生代中的所有对象，并标记出那些仍然在使用的对象。未被标记的对象则被视为垃圾，被清理掉。</li><li>对象晋升：如果某个对象在经历了多次 GC 后仍然存活，那么 CLR 会将它晋升到更老的代别中，直到达到最老的代别。</li><li>跨代 GC：CLR 定期进行跨代 GC，通常会针对二代和三代堆进行操作。这个过程类似于新生代 GC，但需要更多的计算资源和时间。</li></ol><h3 id="suppressfinalize" tabindex="-1"><a class="header-anchor" href="#suppressfinalize"><span>SuppressFinalize</span></a></h3><p>SuppressFinalize() 方法只能被含有终结器方法的类使用，它通知 GC 这个 this 对象已经被手工清理了。 建议在 含有 finalizer 方法的类上使用 IDisposable 模式，参考如下代码：</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> AnalysisSqlHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">IDisposable</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> bool</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> disposed</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    protected</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> virtual</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Dispose</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">bool</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> disposing</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">disposed</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">disposing</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">            _serviceScope</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Dispose</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">        disposed</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Dispose</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">        Dispose</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        // 请求公共语言运行时不要调用该对象上的终结器（在C#中就是指不要调用析构函数）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        GC</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">SuppressFinalize</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    ~</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">AnalysisSqlHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">        Dispose</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通常来说，如果一个含有 finalizer 方法的类被创建，那么 CLR 就会一直密切监控着它，所以它的创建相比普通的类要更加昂贵一些，而 SuppressFinalize 方法就是告诉GC，我已经清除完毕了，你不需要从 FinalizeQueue 中去提取，这就有点像 C++ 的析构函数，但本质上不是一个东西。</p><p>当创建了一个带有 finalizer 方法的类，那这个类的实例地址也会在 FinalizeQueue 中存放一份，当 GC 回收该对象时，GC会将其放到 FreachableQueue 队列中，这样终结器线程就能够从这个队列中提取，进而执行对象的 finalizer 方法，可以参考下面的代码：</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> ConsoleApp5</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Program</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        static</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Main</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">            Run</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">            GC</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Collect</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">            Console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">ReadLine</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        static</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Run</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">            Console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">WriteLine</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;person 已实例化！&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Person</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        ~</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">            Console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">WriteLine</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;我是析构函数！&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">            Console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">ReadLine</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+e+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>接下来问题来了，我能不能不要让终结器线程来执行我的析构函数呢？这就需要用 SuppressFinalize() 方法来抑制了，修改 Run 方法如下：</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" data-title="csharp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Run</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    Console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">WriteLine</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;person 已实例化！&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    GC</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">SuppressFinalize</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">person</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+l+'" alt="" loading="lazy"> 可以看到，这回 终结器线程 没有执行我的析构函数了。</p><h3 id="自动回收" tabindex="-1"><a class="header-anchor" href="#自动回收"><span>自动回收</span></a></h3><p>垃圾回收并非在对象不被引用之后立即执行，而是一个周期进行的。不同的垃圾回收器的调度安排不是确定的，CLR会基于一些因素决定何时开始回收，比如可用的内存、已经分配的内存数目、最后一次内存回收的间隔，这也就代表着对象不被引用和内存释放之间有着不确定的时间间隔，可能几纳秒到几天。</p><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h3><p>1、提高了软件的开发抽象度</p><p>2、程序员可以将经理集中在实际的问题撒花姑娘而不用分心来管理内存的问题</p><p>3、可以使模块的接口更加清洗，减小模块之间的耦合度</p><p>4、大大减少了内存人为管理不当所带来的bug</p><p>5、使内存管理更加高效</p><p>总的来说，GC就是可以使程序员可以从复杂的内存问题中摆脱出来，从而提高了软件开发的速度、质量和安全性。</p><h2 id="内存管理" tabindex="-1"><a class="header-anchor" href="#内存管理"><span>内存管理</span></a></h2><blockquote><p>文章转载自：<a href="https://mp.weixin.qq.com/s/fT23OZmRBN4ANsY5-fPekQ" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/fT23OZmRBN4ANsY5-fPekQ</a></p></blockquote><h3 id="小对象怎么处理的" tabindex="-1"><a class="header-anchor" href="#小对象怎么处理的"><span>小对象怎么处理的？</span></a></h3><p>小型.NET对象被分配到小型对象堆（SOH）上。其中有3种：第0代，第1代和第2代。对象根据其寿命向上移动。 将新对象放在Gen 0上。当Gen 0充满时，.NET垃圾收集器（GC）运行，处理不再需要的对象，并将其他所有内容移至Gen1。如果Gen 1充满，则GC再次运行，也可以将Gen 1中的对象移动到Gen 2中。 当Gen 2变满时，将发生GC完全运行。这将清除不需要的Gen 2对象，将Gen 1对象移至Gen 2，然后将Gen 0对象移至Gen 1，最后清除所有未引用的内容。每次运行GC之后，都会压缩受影响的堆，以将仍在使用的内存保持在一起。 这种代代相传的方法可确保事情高效运行-耗时的压缩过程仅在绝对必要时才会发生。 注意：如果您在Gen 2中看到大量的内存，则表明内存已被保留很长时间，并且可能存在内存问题。这是内存分析工具可以派上用场的地方。</p><h3 id="较大的对象会咋样" tabindex="-1"><a class="header-anchor" href="#较大的对象会咋样"><span>较大的对象会咋样？</span></a></h3><p>大于85 KB的对象被分配到大对象堆（LOH）。由于复制大块内存的开销，它们没有被压缩。当发生完整的GC时，未使用的LOH对象的地址范围将记录在可用空间分配表中。 分配新对象后，将在此可用空间表中检查足以容纳该对象的地址范围。如果存在，则将对象分配到那里，如果不存在，则将对象分配到下一个可用空间。 由于对象不太可能是空地址范围的确切大小，因此对象之间几乎总是会留有小块内存，从而导致碎片。如果这些块小于85 KB，则根本没有重用的可能性。因此，随着分配需求的增加，即使碎片空间仍然可用，也会保留新的段。 此外，当需要分配大对象时，.NET还是倾向于将对象附加到末尾，而不是运行昂贵的Gen 2 GC。这对性能有好处，但是是导致内存碎片的重要原因</p><h3 id="垃圾收集器可以在不同的模式下运行以优化性能" tabindex="-1"><a class="header-anchor" href="#垃圾收集器可以在不同的模式下运行以优化性能"><span>垃圾收集器可以在不同的模式下运行以优化性能</span></a></h3><p>.NET通过为GC提供多种模式来解决性能与堆效率之间的权衡问题。 工作站模式为用户提供了最大的响应速度，并减少了由于GC造成的暂停。它可以作为“并发”或“非并发”运行，指的是运行GC的线程。默认值为并发，它为GC使用单独的线程，因此应用程序可以在GC运行时继续执行。 服务器模式可为服务器环境提供最大的吞吐量，可伸缩性和性能。在服务器模式下，段大小和生成阈值通常比工作站模式大得多，这反映了对服务器的更高要求。 服务器模式在多个线程上并行运行垃圾回收，为每个逻辑处理器分配一个单独的SOH和LOH，以防止线程相互干扰。 .NET框架提供了一种交叉引用机制，因此对象仍然可以在堆之间相互引用。但是，由于应用程序响应能力不是服务器模式的直接目标，因此在GC期间，所有应用程序线程都将被挂起。</p><h3 id="引用不足会在性能和内存效率之间折衷" tabindex="-1"><a class="header-anchor" href="#引用不足会在性能和内存效率之间折衷"><span>引用不足会在性能和内存效率之间折衷</span></a></h3><p>弱对象引用了GC根的替代来源，使您可以保留对象，同时在GC需要时可以收集对象。它们是代码性能和内存效率之间的折衷。创建对象需要占用CPU时间，但保持加载状态需要占用内存。 弱引用特别适用于大型数据结构。例如，假设您有一个允许用户浏览大型数据结构的应用程序，他们可能会返回其中的一些数据。您可以将任何强引用转换为他们浏览的结构为弱引用。如果用户返回到这些结构，则可以使用它们，但如果没有，GC可以根据需要回收内存。</p><h3 id="对象固定可以创建在托管和非托管代码之间传递的引用" tabindex="-1"><a class="header-anchor" href="#对象固定可以创建在托管和非托管代码之间传递的引用"><span>对象固定可以创建在托管和非托管代码之间传递的引用</span></a></h3><p>.NET使用一种称为GCHandle的结构来跟踪堆对象。GCHandle可用于在托管域和非托管域之间传递对象引用，.NET维护一个GCHandles表以实现此目的。GCHandle有四种类型，包括固定的，用于将对象固定在内存中的特定地址。 对象固定的主要问题是它可能导致SOH碎片化。如果将对象固定在GC期间，则根据定义，该对象无法重定位。根据您使用固定的方式，它会降低压缩的效率，在堆中留下间隙。避免这种情况的最佳策略是在很短的时间内锁定，然后释放。</p><h2 id="优化" tabindex="-1"><a class="header-anchor" href="#优化"><span>优化</span></a></h2><p>垃圾回收解放了手工管理对象的工作，提高了程序的健壮性，但副作用就是程序代码可能对于对象创建变得随意。</p><h3 id="避免不必要的对象创建" tabindex="-1"><a class="header-anchor" href="#避免不必要的对象创建"><span>避免不必要的对象创建</span></a></h3><p>由于垃圾回收的代价较高，所以C#程序开发要遵循的一个基本原则就是避免不必要的对象创建。以下列举一些常见的情形。</p><ul><li>避免循环创建对象 ★</li></ul><p>如果对象并不会随每次循环而改变状态，那么在循环中反复创建对象将带来性能损耗。高效的做法是将对象提到循环外面创建。</p><ul><li>在需要逻辑分支中创建对象</li></ul><p>如果对象只在某些逻辑分支中才被用到，那么应只在该逻辑分支中创建对象。</p><ul><li>使用常量避免创建对象</li></ul><p>程序中不应出现如 new Decimal(0) 之类的代码，这会导致小对象频繁创建及回收，正确的做法是使用Decimal.Zero常量。我们有设计自己的类时，也可以学习这个设计手法，应用到类似的场景中。</p><ul><li>使用StringBuilder做字符串连接</li></ul><h3 id="不要使用空析构函数-★" tabindex="-1"><a class="header-anchor" href="#不要使用空析构函数-★"><span>不要使用空析构函数 ★</span></a></h3><p>如果类包含析构函数，由创建对象时会在 Finalize 队列中添加对象的引用，以保证当对象无法可达时，仍然可以调用到 Finalize 方法。垃圾回收器在运行期间，会启动一个低优先级的线程处理该队列。相比之下，没有析构函数的对象就没有这些消耗。如果析构函数为空，这个消耗就毫无意 义，只会导致性能降低！因此，不要使用空的析构函数。</p><p>在实际情况中，许多曾在析构函数中包含处理代码，但后来因为种种原因被注释掉或者删除掉了，只留下一个空壳，此时应注意把析构函数本身注释掉或删除掉。</p><h3 id="实现-idisposable-接口" tabindex="-1"><a class="header-anchor" href="#实现-idisposable-接口"><span>实现 IDisposable 接口</span></a></h3><p>垃圾回收事实上只支持托管内在的回收，对于其他的非托管资源，例如 Window GDI 句柄或数据库连接，在析构函数中释放这些资源有很大问题。原因是垃圾回收依赖于内在紧张的情况，虽然数据库连接可能已濒临耗尽，但如果内存还很充足的话， 垃圾回收是不会运行的。</p><p>C#的 IDisposable 接口是一种显式释放资源的机制。通过提供 using 语句，还简化了使用方式（编译器自动生成 try ... finally 块，并在 finally 块中调用 Dispose 方法）。对于申请非托管资源对象，应为其实现 IDisposable 接口，以保证资源一旦超出 using 语句范围，即得到及时释放。这对于构造健壮且性能优良的程序非常有意义！</p><p>为防止对象的 Dispose 方法<strong>不被调用</strong>的情况发生，一般还要提供析构函数，两者调用一个处理资源释放的公共方法。同时，Dispose 方法应调用<code> System.GC.SuppressFinalize(this)</code>，告诉垃圾回收器无需再处理 Finalize 方法了。</p><h2 id="工具" tabindex="-1"><a class="header-anchor" href="#工具"><span>工具</span></a></h2><h3 id="gummycat" tabindex="-1"><a class="header-anchor" href="#gummycat"><span>GummyCat</span></a></h3><p>可视化 .NET 垃圾收集器的活动，一个显示.NET 堆的内存布局并可视化 GC 操作的工具</p><p>文档地址：https://minidump.net/gummycat/</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><p><a href="https://mp.weixin.qq.com/s/70oO9sEDoMHmFxvjOdtDYw" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/70oO9sEDoMHmFxvjOdtDYw</a> | 什么时候应该调用 GC.SuppressFinalize()? <a href="https://learn.microsoft.com/zh-cn/dotnet/standard/garbage-collection/implementing-dispose" target="_blank" rel="noopener noreferrer">https://learn.microsoft.com/zh-cn/dotnet/standard/garbage-collection/implementing-dispose</a></p>',62),h=[t];function k(r,d){return a(),i("div",null,h)}const o=s(p,[["render",k],["__file","index.html.vue"]]),B=JSON.parse('{"path":"/dotnet/csharp/garbageCollection/","title":"说明","lang":"zh-CN","frontmatter":{"title":"说明","lang":"zh-CN","date":"2023-10-22T00:00:00.000Z","publish":true,"author":"azrng","isOriginal":true,"category":["csharp"],"tag":["无"],"filename":"lajihuishou","slug":"prttb8","docsId":"29634760","description":"概述 内存是有效的，不可能无止境分配空间，因此就产生了GC的需求。 Gc .NET GC (Garbage Collection) 是自动内存管理的一种方式，可以帮助开发者避免手动释放内存而导致的许多问题。在 .NET 环境下，GC 会定期扫描程序中的堆（heap）对象，标记出已经不再使用的对象并将其回收。 漫画解释GC原理：https://blog....","head":[["meta",{"property":"og:url","content":"https://azrng.gitee.io/kbms/kbms/dotnet/csharp/garbageCollection/"}],["meta",{"property":"og:site_name","content":"知识库"}],["meta",{"property":"og:title","content":"说明"}],["meta",{"property":"og:description","content":"概述 内存是有效的，不可能无止境分配空间，因此就产生了GC的需求。 Gc .NET GC (Garbage Collection) 是自动内存管理的一种方式，可以帮助开发者避免手动释放内存而导致的许多问题。在 .NET 环境下，GC 会定期扫描程序中的堆（heap）对象，标记出已经不再使用的对象并将其回收。 漫画解释GC原理：https://blog...."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://azrng.gitee.io/kbms/kbms/common/1646058570865-e5afe134-558f-4e70-aee1-49276f97c1eb.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-05T13:41:53.000Z"}],["meta",{"property":"article:author","content":"azrng"}],["meta",{"property":"article:tag","content":"无"}],["meta",{"property":"article:published_time","content":"2023-10-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-05T13:41:53.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"说明\\",\\"image\\":[\\"https://azrng.gitee.io/kbms/kbms/common/1646058570865-e5afe134-558f-4e70-aee1-49276f97c1eb.png\\",\\"https://azrng.gitee.io/kbms/kbms/common/1646058609063-e0eec184-b082-43ae-af0f-179fa5885081.png\\"],\\"datePublished\\":\\"2023-10-22T00:00:00.000Z\\",\\"dateModified\\":\\"2024-05-05T13:41:53.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"azrng\\"}]}"]]},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":2,"title":"Gc","slug":"gc","link":"#gc","children":[{"level":3,"title":"SuppressFinalize","slug":"suppressfinalize","link":"#suppressfinalize","children":[]},{"level":3,"title":"自动回收","slug":"自动回收","link":"#自动回收","children":[]},{"level":3,"title":"优点","slug":"优点","link":"#优点","children":[]}]},{"level":2,"title":"内存管理","slug":"内存管理","link":"#内存管理","children":[{"level":3,"title":"小对象怎么处理的？","slug":"小对象怎么处理的","link":"#小对象怎么处理的","children":[]},{"level":3,"title":"较大的对象会咋样？","slug":"较大的对象会咋样","link":"#较大的对象会咋样","children":[]},{"level":3,"title":"垃圾收集器可以在不同的模式下运行以优化性能","slug":"垃圾收集器可以在不同的模式下运行以优化性能","link":"#垃圾收集器可以在不同的模式下运行以优化性能","children":[]},{"level":3,"title":"引用不足会在性能和内存效率之间折衷","slug":"引用不足会在性能和内存效率之间折衷","link":"#引用不足会在性能和内存效率之间折衷","children":[]},{"level":3,"title":"对象固定可以创建在托管和非托管代码之间传递的引用","slug":"对象固定可以创建在托管和非托管代码之间传递的引用","link":"#对象固定可以创建在托管和非托管代码之间传递的引用","children":[]}]},{"level":2,"title":"优化","slug":"优化","link":"#优化","children":[{"level":3,"title":"避免不必要的对象创建","slug":"避免不必要的对象创建","link":"#避免不必要的对象创建","children":[]},{"level":3,"title":"不要使用空析构函数 ★","slug":"不要使用空析构函数-★","link":"#不要使用空析构函数-★","children":[]},{"level":3,"title":"实现 IDisposable 接口","slug":"实现-idisposable-接口","link":"#实现-idisposable-接口","children":[]}]},{"level":2,"title":"工具","slug":"工具","link":"#工具","children":[{"level":3,"title":"GummyCat","slug":"gummycat","link":"#gummycat","children":[]}]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1700232644000,"updatedTime":1714916513000,"contributors":[{"name":"azrng","email":"itzhangyunpeng@163.com","commits":6}]},"readingTime":{"minutes":11.08,"words":3323},"filePathRelative":"dotnet/csharp/garbageCollection/readme.md","localizedDate":"2023年10月22日","excerpt":"<h2>概述</h2>\\n<p>内存是有效的，不可能无止境分配空间，因此就产生了GC的需求。</p>\\n<h2>Gc</h2>\\n<p>.NET GC (Garbage Collection) 是自动内存管理的一种方式，可以帮助开发者避免手动释放内存而导致的许多问题。在 .NET 环境下，GC 会定期扫描程序中的堆（heap）对象，标记出已经不再使用的对象并将其回收。</p>\\n<p>漫画解释GC原理：<a href=\\"https://blog.kitlau.dev/posts/cartoon-dotnet-garbage-collection/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://blog.kitlau.dev/posts/cartoon-dotnet-garbage-collection/</a></p>","autoDesc":true}');export{o as comp,B as data};
